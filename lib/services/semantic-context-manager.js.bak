/**
 * Semantic Context Manager
 * 
 * Integrates the semantic embeddings module with the improved context manager
 * to provide enhanced context retrieval based on semantic similarity.
 * Now also integrates with the semantic chunker for improved chunking.
 * 
 * IMPORTANT: This component follows the standardized conventions defined in LEO_STANDARDIZATION.md
 */

const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;
const { createComponentLogger } = require('../utils/logger');
const improvedContextManager = require('./improved-context-manager');
/**
 * STANDARDIZED ACCESS PATTERN
 * 
 * This module follows the standardized access pattern for semantic context operations.
 * All components should access semantic functionality through this manager or its adapter.
 * Direct access to the true-semantic-embeddings module should be avoided.
 */

// Embeddings interface will be injected via options (dependency injection)
let embeddingsInterface = null;

// Track initialization state
let isInitialized = false;

// Standardized error messages
const ERROR_MESSAGES = {
  NOT_INITIALIZED: 'Semantic context manager not initialized',
  EMBEDDINGS_UNAVAILABLE: 'Embeddings interface not available',
  INVALID_QUERY: 'Invalid query provided',
  INVALID_VECTOR: 'Invalid vector provided',
  BOUNDARY_CROSSING_FAILED: 'Failed to preserve context across token boundary',
  CONTEXT_RESTORATION_FAILED: 'Failed to restore context after token boundary'
};
const configService = require('./config-service');
const semanticChunker = require('../adapters/semantic-chunker-adapter');
const pathUtils = require('../utils/path-utils');
const eventBus = require('../utils/event-bus');

// Import session boundary manager for token boundary awareness
let sessionBoundaryManager;
try {
  sessionBoundaryManager = require('./session-boundary-manager');
} catch (error) {
  // Create a fallback if the session boundary manager is not available
  sessionBoundaryManager = {
    isInitialized: false,
    initialize: async () => true,
    getCurrentSession: () => ({
      id: 'fallback-session',
      startTime: Date.now(),
      tokenEstimate: 0,
      boundaryProximity: { status: 'unknown' }
    }),
    getBoundaryProximity: () => ({ status: 'unknown', percentage: 0 }),
    setCurrentTask: () => true
  };
}

// Token boundary awareness state
let boundaryAwarenessEnabled = true;
let lastBoundaryStatus = 'unknown';
let contextPreservationState = {
  isPreserving: false,
  lastPreservedContext: null,
  preservationTimestamp: 0,
  boundaryId: null
};

// Create component logger
const logger = createComponentLogger('semantic-context-manager');

// Component name for event and config subscriptions
const COMPONENT_NAME = 'semantic-context-manager';

// Configuration object - using standardized access patterns
let CONFIG = {};

// Initialize configuration with standardized property paths
function initializeConfig() {
  CONFIG = {
    // Context retrieval settings
    similarityThreshold: configService.getConfig('contextManager.minSimilarityThreshold', 0.2),
    maxResults: configService.getConfig('contextManager.maxContextItems', 10),
    ENABLE_CORPUS_STATS: configService.getConfig('contextManager.enableCorpusStats', true),
    
    // Cache settings
    QUERY_CACHE_SIZE: configService.getConfig('contextManager.maxCacheItems', 1000),
    QUERY_CACHE_TTL: configService.getConfig('contextManager.cacheExpiration', 3600) * 1000,
    
    // Chunking settings
    USE_SEMANTIC_CHUNKER: configService.getConfig('chunking.useSemanticChunker', true),
    MAX_CHUNK_SIZE: configService.getConfig('chunking.maxChunkSize', 1000),
    OVERLAP_SIZE: configService.getConfig('chunking.chunkOverlap', 50),
    
    // Embedding settings
    EMBEDDING_DIMENSIONS: configService.getConfig('embedding.dimensions', 384),
    
    // File paths (using standardized property paths)
    embeddingsFile: configService.getConfig('paths.embeddings', pathUtils.join(process.cwd(), 'data', 'embeddings.jsonl')),
    chunksFile: configService.getConfig('paths.chunks', pathUtils.join(process.cwd(), 'data', 'chunks.jsonl')),
    cacheDir: configService.getConfig('paths.cache', pathUtils.join(process.cwd(), 'data', 'cache'))
  };
  
  logger.info('Configuration initialized', { 
    maxResults: CONFIG.maxResults,
    useSemanticChunker: CONFIG.USE_SEMANTIC_CHUNKER,
    embeddingDimensions: CONFIG.EMBEDDING_DIMENSIONS
  });
}

// Initialize configuration
initializeConfig();

// Subscribe to configuration changes
configService.subscribe(COMPONENT_NAME, (event, data) => {
  if (event === 'updated') {
    logger.info('Configuration updated, reinitializing');
    initializeConfig();
  }
});

// Cache for query results with timestamps for invalidation
const queryCache = new Map();
const cacheTimestamps = new Map();
let chunks = [];
let embeddings = [];

// Track cache statistics
const cacheStats = {
  hits: 0,
  misses: 0,
  invalidations: 0,
  size: 0
};

/**
 * Get cache statistics
 * @returns {Object} Standardized result with cache statistics
 */
function getCacheStats() {
  return {
    success: true,
    stats: { ...cacheStats },
    metadata: {
      timestamp: Date.now()
    }
  };
}

// Subscribe to relevant events
eventBus.on('file:changed', handleFileChanged, COMPONENT_NAME);
eventBus.on('file:deleted', handleFileDeleted, COMPONENT_NAME);
eventBus.on('cache:invalidated', handleCacheInvalidated, COMPONENT_NAME);

// Subscribe to boundary health events for proactive context preservation
eventBus.on('boundary-health:status', handleBoundaryHealthStatus, COMPONENT_NAME);
eventBus.on('boundary-health:critical-threshold', handleCriticalBoundaryThreshold, COMPONENT_NAME);

/**
 * Handle file changed event
 * @param {Object} data - Event data
 * @private
 */
function handleFileChanged(data) {
  if (data && data.path) {
    invalidateCache(data.path);
  }
}

/**
 * Handle file deleted event
 * @param {Object} data - Event data
 * @private
 */
function handleFileDeleted(data) {
  if (data && data.path) {
    invalidateCache(data.path);
  }
}

/**
 * Handle cache invalidated event
 * @param {Object} data - Event data
 * @private
 */
function handleCacheInvalidated(data) {
  try {
    if (data && data.type === 'all') {
      logger.info('Invalidating all caches due to global cache invalidation event');
      if (queryCache) {
        queryCache.clear();
      }
    } else if (data && data.type === 'query') {
      logger.info('Invalidating query cache due to query cache invalidation event');
      if (queryCache) {
        queryCache.clear();
      }
    }
  } catch (error) {
    logger.error(`Error handling cache invalidation event: ${error.message}`);
  }
}

/**
 * Handle boundary health status event for proactive context preservation
 * @param {Object} data - Boundary health status data
 * @private
 */
function handleBoundaryHealthStatus(data) {
  // Only take action if boundary awareness is enabled
  if (!boundaryAwarenessEnabled) {
    return;
  }
  
  try {
    // Update last boundary status
    lastBoundaryStatus = data.boundaryStatus;
    
    // Take proactive action based on boundary status
    if (data.boundaryStatus === 'warning' && !contextPreservationState.isPreserving) {
      // Start preparing for context preservation when we get a warning
      logger.info('Boundary warning detected, preparing for proactive context preservation');
      
      // Begin background context preservation without disrupting the user
      preserveContextForBoundaryCrossing(false).catch(error => {
        logger.warn(`Error in proactive context preservation: ${error.message}`);
      });
    }
  } catch (error) {
    logger.warn(`Error handling boundary health status: ${error.message}`);
  }
}

/**
 * Handle critical boundary threshold event for immediate context preservation
 * @param {Object} data - Critical boundary threshold data
 * @private
 */
function handleCriticalBoundaryThreshold(data) {
  // Only take action if boundary awareness is enabled
  if (!boundaryAwarenessEnabled) {
    return;
  }
  
  try {
    if (data.requiresAction) {
      logger.warn('Critical boundary threshold detected, immediate context preservation required');
      
      // Force context preservation
      preserveContextForBoundaryCrossing(true).catch(error => {
        logger.error(`Error in critical context preservation: ${error.message}`);
        
        // Emit error event
        eventBus.emit('semantic-context-manager:preservation-failure', {
          error: error.message,
          timestamp: Date.now()
        });
      });
    }
  } catch (error) {
    logger.error(`Error handling critical boundary threshold: ${error.message}`);
  }
}

let corpusStats = {};
let lastEmbeddingsLoadTime = 0;
let lastChunksLoadTime = 0;
// isInitialized is declared at the top of the file

/**
 * Check if embeddings and chunks need to be reloaded
 * @returns {boolean} True if reload is needed
 * @private
 */
function needsReload() {
  // Check file modification times
  const embeddingsPath = pathUtils.normalize(CONFIG.embeddingsFile);
  const chunksPath = pathUtils.normalize(CONFIG.chunksFile);
  
  try {
    const embeddingsStats = fs.statSync(embeddingsPath);
    const chunksStats = fs.statSync(chunksPath);
    
    const embeddingsModTime = embeddingsStats.mtimeMs;
    const chunksModTime = chunksStats.mtimeMs;
    
    // Reload if files have been modified since last load
    if (embeddingsModTime > lastEmbeddingsLoadTime || chunksModTime > lastChunksLoadTime) {
      logger.info('Embeddings or chunks files have been modified, reload needed');
      return true;
    }
    
    // Reload if we have no data
    if (embeddings.length === 0 || chunks.length === 0) {
      logger.info('No embeddings or chunks loaded, reload needed');
      return true;
    }
    
    // Reload if it's been more than 1 hour since last load
    const oneHour = 60 * 60 * 1000;
    if (Date.now() - lastEmbeddingsLoadTime > oneHour || Date.now() - lastChunksLoadTime > oneHour) {
      logger.info('More than 1 hour since last load, reload needed');
      return true;
    }
    
    return false;
  } catch (error) {
    logger.warn(`Error checking if reload is needed: ${error.message}`);
    return true; // Reload on error to be safe
  }
}

/**
 * Build corpus statistics for improved relevance scoring
 * @returns {Promise<Object>} Corpus statistics
 * @private
 */
async function buildCorpusStats() {
  try {
    logger.info('Building corpus statistics...');
    
    const startTime = Date.now();
    const stats = {
      terms: {},
      documentCount: chunks.length,
      averageDocumentLength: 0,
      totalTerms: 0
    };
    
    // Calculate term frequencies and document frequencies
    let totalLength = 0;
    
    for (const chunk of chunks) {
      const content = chunk.content || chunk.text || '';
      const terms = content.toLowerCase().split(/\W+/).filter(term => term.length > 1);
      
      totalLength += terms.length;
      
      // Count unique terms in this document
      const uniqueTerms = new Set(terms);
      
      for (const term of uniqueTerms) {
        if (!stats.terms[term]) {
          stats.terms[term] = {
            documentFrequency: 1,
            termFrequency: 0
          };
        } else {
          stats.terms[term].documentFrequency += 1;
        }
      }
      
      // Count term frequencies
      for (const term of terms) {
        if (stats.terms[term]) {
          stats.terms[term].termFrequency += 1;
        }
      }
    }
    
    // Calculate average document length
    stats.averageDocumentLength = totalLength / chunks.length;
    stats.totalTerms = Object.keys(stats.terms).length;
    
    // Save corpus stats to cache
    const statsPath = path.join(CONFIG.cacheDir, 'corpus-stats.json');
    
    // Use promisified fs.writeFile or handle callback properly
    await new Promise((resolve, reject) => {
      fs.writeFile(statsPath, JSON.stringify(stats, null, 2), (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
    
    logger.info(`Built corpus statistics with ${stats.totalTerms} terms and ${stats.documentCount} documents in ${Date.now() - startTime}ms`);
    
    return stats;
  } catch (error) {
    logger.error(`Failed to build corpus statistics: ${error.message}`);
    return {
      terms: {},
      documentCount: 0,
      averageDocumentLength: 0,
      totalTerms: 0
    };
  }
}

/**
 * Initialize the semantic context manager
 * @param {Object} options - Initialization options
 * @param {Object} [options.embeddingsInterface] - Optional embeddings interface to use directly
 * @returns {Promise<boolean>} - Success status
 */
async function initialize(options = {}) {
  // Emit initialization start event
  eventBus.emit('semantic-context-manager:initializing', {
    timestamp: Date.now()
  });
  
  // Prevent duplicate initialization
  if (isInitialized) {
    logger.info('Semantic context manager already initialized');
    
    // Emit already initialized event
    eventBus.emit('semantic-context-manager:initialized', {
      success: true,
      status: 'already-initialized',
      timestamp: Date.now()
    });
    
    return true;
  }

  logger.info('Initializing semantic context manager with local embeddings...');

  try {
    // Initialize configuration
    try {
      // Check if files exist
      const embeddingsExists = fs.existsSync(CONFIG.embeddingsFile);
      const chunksExists = fs.existsSync(CONFIG.chunksFile);
      
      if (!embeddingsExists) {
        logger.warn(`Embeddings file not found: ${CONFIG.embeddingsFile}`);
      }
      
      if (!chunksExists) {
        logger.warn(`Chunks file not found: ${CONFIG.chunksFile}`);
      }
      
      // Create cache directory if it doesn't exist
      if (!fs.existsSync(CONFIG.cacheDir)) {
        logger.info(`Creating cache directory: ${CONFIG.cacheDir}`);
        fs.mkdirSync(CONFIG.cacheDir, { recursive: true });
      }
      
      // Initialize the local embeddings interface
      if (embeddingsInterface) {
        logger.info('Initializing local embeddings interface...');
        try {
          if (typeof embeddingsInterface.initialize === 'function') {
            await embeddingsInterface.initialize();
          }
          logger.info('Local embeddings interface initialized successfully');
        } catch (embeddingError) {
          logger.error(`Failed to initialize local embeddings: ${embeddingError.message}`);
          throw new Error(`Embeddings initialization failed: ${embeddingError.message}`);
        }
      } else {
        throw new Error('Embeddings interface not available');
      }
    } catch (configError) {
      logger.error(`Error during configuration: ${configError.message}`);
      throw configError; // Re-throw to be caught by outer try-catch
    }
    
    // Initialize session boundary manager if not already initialized
    if (sessionBoundaryManager && !sessionBoundaryManager.isInitialized) {
      try {
        logger.info('Initializing session boundary manager for token boundary awareness');
        await sessionBoundaryManager.initialize();
        logger.info('Session boundary manager initialized successfully');
        
        // Set up boundary check interval
        setInterval(checkBoundaryProximity, 60000); // Check every minute
        
        // Check for continuity token in options
        if (options.continuityToken) {
          logger.info('Continuity token detected, attempting to restore context');
          // Attempt to restore context from previous session
          await restoreContextAfterBoundaryCrossing();
        }
      } catch (boundaryError) {
        logger.warn(`Failed to initialize session boundary manager: ${boundaryError.message}`);
        // Continue anyway, with reduced boundary awareness capabilities
      }
    } else if (sessionBoundaryManager && sessionBoundaryManager.isInitialized) {
      logger.info('Session boundary manager already initialized');
      // Set up boundary check interval
      setInterval(checkBoundaryProximity, 60000); // Check every minute
    } else {
      logger.warn('Session boundary manager not available, token boundary awareness will be limited');
      boundaryAwarenessEnabled = false;
    }
    
    // Initialize embeddings interface
    logger.info('Initializing embeddings interface');
    let embeddingsInitialized = false;
    
    // Only use injected embeddings interface
    if (options && options.embeddingsInterface) {
      logger.info('Using embeddings interface provided in options');
      embeddingsInterface = options.embeddingsInterface;
      embeddingsInitialized = true;
    } else {
      logger.error('No embeddings interface provided. Please inject embeddingsInterface via options.');
      throw new Error('Embeddings interface must be injected into semantic-context-manager.');
    }
    
    // Verify the interface has the required methods
    if (!embeddingsInterface.generate || !embeddingsInterface.cosineSimilarity) {
      logger.error('Embeddings interface is missing required methods');
      throw new Error('Embeddings interface must have generate and cosineSimilarity methods');
    }
    
    // Helper and invocation are now strictly inside initialize
    const verifyAndInitEmbeddings = async (embeddingsInterface) => {
      try {
        if (typeof embeddingsInterface.initialize === 'function') {
          await embeddingsInterface.initialize();
        }
        if (typeof embeddingsInterface.generate === 'function') {
          const testEmbedding = await embeddingsInterface.generate('test');
          if (!Array.isArray(testEmbedding)) {
            throw new Error('Embeddings interface failed to generate a valid embedding');
          }
          logger.info('Embeddings interface verified with test embedding generation');
        }
      } catch (testError) {
        logger.error(`Test embedding generation or initialization failed: ${testError.message}`);
        throw testError;
      }
      return embeddingsInterface;
    };
    embeddingsInterface = await verifyAndInitEmbeddings(embeddingsInterface);

    // Initialize cache
    try {
      // Clear the cache
      if (queryCache && typeof queryCache.clear === 'function') {
        queryCache.clear();
        
        // Set up cache maintenance interval
        setInterval(() => {
          try {
            // Remove expired cache entries
            const now = Date.now();
            for (const [key, value] of queryCache.entries()) {
              if (now - value.timestamp > CONFIG.QUERY_CACHE_TTL) {
                queryCache.delete(key);
              }
            }
            
            // Limit cache size
            if (queryCache.size > CONFIG.QUERY_CACHE_SIZE) {
              const keys = Array.from(queryCache.keys());
              for (let i = 0; i < keys.length - CONFIG.QUERY_CACHE_SIZE; i++) {
                queryCache.delete(keys[i]);
              }
            }
          } catch (maintenanceError) {
            logger.warn(`Error in cache maintenance: ${maintenanceError.message}`);
          }
        }, 60000); // Clean up cache every minute
        
        logger.info('Cache initialized successfully');
      } else {
        logger.warn('Query cache not available or missing clear method');
      }
    } catch (cacheError) {
      logger.warn(`Error initializing cache: ${cacheError.message}`);
      // Continue anyway
    }
    
    // Verify embeddings are properly initialized
    if (!embeddingsInterface || (embeddingsInterface.isInitialized && !embeddingsInterface.isInitialized())) {
      const errorMsg = 'Embeddings interface not properly initialized';
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    
    // Make the embeddings interface available on the module exports
    module.exports.embeddingsInterface = embeddingsInterface;
    
    // Mark as initialized
    isInitialized = true;
    module.exports.isInitialized = true;
    
    // Emit initialization complete event
    const initEvent = {
      success: true,
      status: 'initialized',
      timestamp: Date.now(),
      embeddingsAvailable: true,
      boundaryAwarenessEnabled: boundaryAwarenessEnabled,
      embeddingsType: 'local-tfidf',
      embeddingDimensions: 1024 // Fixed dimension for our local implementation
    };
    
    // Emit both specific and standardized events
    eventBus.emit('semantic-context-manager:initialized', initEvent);
    eventBus.emit('component:initialized', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      status: 'success',
      details: initEvent
    });
    
    logger.info('Semantic context manager initialized successfully with local embeddings');
    return true;
  } catch (error) {
    const errorDetails = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code
    };
    
    logger.error('Failed to initialize semantic context manager', errorDetails);
    
    // Emit error event
    eventBus.emit('semantic-context-manager:initialization-failed', {
      error: errorDetails,
      timestamp: Date.now()
    });
    eventBus.emit('component:error', {
      component: COMPONENT_NAME,
      error: errorDetails,
      timestamp: Date.now(),
      details: errorDetails
    });
    
    return false;
  }
}

/**
 * Analyze query to determine its characteristics
 * @param {string} query - Query text
 * @returns {Object} Standardized result with query analysis and metadata
 */
function analyzeQuery(query) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized');
      return {
        success: false,
        error: 'Semantic context manager not initialized',
        analysis: {
          type: 'unknown',
          isCodeQuery: false,
          isDocumentationQuery: false,
          isStructuralQuery: false,
          confidence: 0
        },
        metadata: {
          query,
          timestamp: Date.now(),
          status: 'error'
        }
      };
    }
    
    const lowerQuery = query.toLowerCase();
    
    // Check if query is code-specific
    const codeKeywords = [
      'function', 'class', 'method', 'variable', 'import', 'export',
      'parameter', 'return', 'code', 'implementation', 'syntax',
      'api', 'interface', 'module', 'component', 'algorithm'
    ];
    
    const isCodeQuery = codeKeywords.some(keyword => lowerQuery.includes(keyword)) ||
      /\bcode\b|\bfunction\b|\bclass\b|\bmethod\b|\bimplementation\b/.test(lowerQuery);
    
    // Check if query is explanatory
    const isExplanatoryQuery = lowerQuery.startsWith('how') || 
      lowerQuery.startsWith('explain') || 
      lowerQuery.startsWith('what is') ||
      lowerQuery.includes('describe') ||
      lowerQuery.includes('explain');
    
    // Check if query is about a specific file or path
    const isFileSpecificQuery = lowerQuery.includes('.js') || 
      lowerQuery.includes('.py') || 
      lowerQuery.includes('.md') ||
      lowerQuery.includes('file') ||
      lowerQuery.includes('directory') ||
      lowerQuery.includes('path');
    
    // Extract target file from query
    const targetFile = isFileSpecificQuery ? lowerQuery.split(' ').pop() : null;
    
    return {
      success: true,
      analysis: {
        type: isCodeQuery ? 'code' : isExplanatoryQuery ? 'explanatory' : 'unknown',
        isCodeQuery,
        isDocumentationQuery: isExplanatoryQuery,
        isStructuralQuery: isFileSpecificQuery,
        confidence: isCodeQuery || isExplanatoryQuery || isFileSpecificQuery ? 0.8 : 0.2
      },
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'success'
      }
    };
  } catch (error) {
    logger.error(`Error analyzing query: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Error analyzing query', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      analysis: {
        type: 'unknown',
        isCodeQuery: false,
        isDocumentationQuery: false,
        isStructuralQuery: false,
        confidence: 0
      },
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Search for context using semantic similarity
 * @param {string} query - Query text
 * @param {Object} options - Search options including signal for timeout control
 * @param {AbortSignal} [options.signal] - AbortController signal for timeout control
 * @returns {Promise<Array>} Search results
 */
async function searchContext(query, options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    // Track metrics
    const startTime = Date.now();
    
    // Check for abort signal
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // Check if we need to reload embeddings and chunks
    if (embeddings.length === 0 || chunks.length === 0 || needsReload()) {
      logger.info('Loading embeddings and chunks');
      
      try {
        // Load embeddings using path utilities
        const embeddingsPath = pathUtils.normalize(CONFIG.embeddingsFile);
        if (!await pathUtils.exists(embeddingsPath)) {
          throw new Error(`Embeddings file not found: ${embeddingsPath}`);
        }
        
        // Read embeddings file
        const embeddingsData = await pathUtils.readFile(embeddingsPath);
        embeddings = embeddingsData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastEmbeddingsLoadTime = Date.now();
        
        // Load chunks using path utilities
        const chunksPath = pathUtils.normalize(CONFIG.chunksFile);
        if (!await pathUtils.exists(chunksPath)) {
          throw new Error(`Chunks file not found: ${chunksPath}`);
        }
        
        // Read chunks file
        const chunksData = await pathUtils.readFile(chunksPath);
        chunks = chunksData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastChunksLoadTime = Date.now();
        
        // Build corpus stats
        if (CONFIG.ENABLE_CORPUS_STATS) {
          corpusStats = await buildCorpusStats();
        }
        
        // Emit data loaded event
        eventBus.emit('context:data:loaded', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          embeddingsCount: embeddings.length,
          chunksCount: chunks.length,
          loadTime: Date.now() - startTime
        });
        
        logger.info(`Loaded ${embeddings.length} embeddings and ${chunks.length} chunks in ${Date.now() - startTime}ms`);
      } catch (error) {
        logger.error(`Failed to load embeddings or chunks: ${error.message}`);
        
        // Emit error event
        eventBus.emit('context:data:error', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          error: error.message
        });
        
        return {
          success: false,
          error: error.message,
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    // Set up options with standardized configuration access
    // Use a lower default similarity threshold to ensure more results
    const similarityThreshold = options.similarityThreshold || CONFIG.similarityThreshold || 0.15;
    const maxResults = options.maxResults || CONFIG.maxResults || 15; // Increase default max results
    const cacheKey = `${query}:${similarityThreshold}:${maxResults}`;
    
    // Check cache first
    if (queryCache.has(cacheKey)) {
      const cacheEntry = queryCache.get(cacheKey);
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // Only use cache if it's not too old (using configured TTL)
      if (cacheAge < CONFIG.queryCacheTtl) {
        logger.debug('Using cached context', { query, cacheAge: `${Math.round(cacheAge/1000)}s` });
        
        // Emit cache hit event
        eventBus.emit('context:cache:hit', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
          cacheAge
        });
        
        return {
          success: true,
          results: cacheEntry.results,
          metadata: {
            query,
            timestamp: Date.now(),
            count: cacheEntry.results.length,
            options: {
              similarityThreshold,
              maxResults
            }
          }
        };
      }
    }
    
    // Analyze query to determine boosting strategy
    const analysis = analyzeQuery(query);
    logger.debug('Query analysis', { analysis });
    
    // Check if operation has been aborted
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // Generate query embedding using standardized function
    const queryEmbedding = await generateQueryEmbedding(query);
    
    // Track similarity calculation time
    const similarityStartTime = Date.now();
    
    // Calculate similarity scores with standardized approach
    const results = embeddings.map((item, index) => {
      // Get corresponding chunk
      const chunk = chunks[index] || {};
      
      // Calculate cosine similarity using local embeddings interface
      let similarity;
      try {
        // Primary approach: use our local embeddings interface
        if (embeddingsInterface && typeof embeddingsInterface.cosineSimilarity === 'function') {
          similarity = embeddingsInterface.cosineSimilarity(
            queryEmbedding,
            item.embedding || item.vector // Support both embedding and vector keys
          );
        }
        // Fallback: use the module's cosineSimilarity function
        else if (typeof trueSemanticEmbeddings.cosineSimilarity === 'function') {
          similarity = trueSemanticEmbeddings.cosineSimilarity(
            queryEmbedding,
            item.embedding || item.vector // Support both embedding and vector keys
          );
        }
        else {
          // Final fallback: simple dot product calculation
          logger.error('No cosine similarity function available');
          throw new Error('No cosine similarity function available');
        }
      } catch (error) {
        logger.error(`Error calculating similarity: ${error.message}`);
        similarity = 0; // Default to zero similarity on error
      }
      
      // Apply intelligent boosting based on query analysis
      let boostedSimilarity = similarity;
      
      // Infer chunk type using standardized function
      const chunkType = inferChunkType(chunk);
      
      // Apply boosting based on query type and chunk type
      if (analysis.isCodeQuery && chunkType === 'code') {
        boostedSimilarity *= 1.3; // Boost code chunks for code queries
      } else if (analysis.isDocumentationQuery && chunkType === 'documentation') {
        boostedSimilarity *= 1.3; // Boost documentation for documentation queries
      } else if (analysis.isStructuralQuery && chunk.path && chunk.path.includes(analysis.targetFile)) {
        boostedSimilarity *= 1.5; // Boost chunks from the target file
      }
      
      // Emit similarity calculated event (for every 100th item to avoid event flood)
      if (index % 100 === 0) {
        eventBus.emit('context:similarity:calculated', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          chunkType,
          similarity: Math.round(similarity * 100) / 100,
          boostedSimilarity: Math.round(boostedSimilarity * 100) / 100
        });
      }
      
      return {
        id: chunk.chunk_id || `chunk_${index}`,
        path: chunk.file || item.file,
        content: chunk.content || item.content,
        text: chunk.text || item.text, // Support both content and text properties
        similarity: boostedSimilarity,
        originalSimilarity: similarity,
        type: chunkType
      };
    });
    
    // Sort by boosted similarity
    results.sort((a, b) => b.similarity - a.similarity);
    
    // Filter by similarity threshold
    const filteredResults = results.filter(item => item.similarity >= similarityThreshold);
    
    // Track results metrics
    const initialResultCount = filteredResults.length;
    
    // Limit results
    const topResults = filteredResults.slice(0, maxResults);
    
    // Calculate similarity time
    const similarityTime = Date.now() - similarityStartTime;
    logger.debug(`Calculated similarity for ${embeddings.length} embeddings in ${similarityTime}ms`);
    
    // Add results to cache
    queryCache.set(cacheKey, {
      results: topResults,
      timestamp: Date.now()
    });
    
    // Emit cache miss event
    eventBus.emit('context:cache:miss', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
      resultCount: topResults.length,
      searchTime: Date.now() - startTime
    });
    
    return {
      success: true,
      results: topResults,
      metadata: {
        query,
        timestamp: Date.now(),
        count: topResults.length,
        searchTime: Date.now() - startTime,
        searchType: 'semantic',
        options: {
          similarityThreshold,
          maxResults
        }
      }
    };
  } catch (error) {
    logger.error(`Error in searchContext: ${error.message}`);
    
    // Emit error event
    eventBus.emit('context:search:error', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
      error: error.message
    });
    
    return {
      success: false,
      error: error.message,
      results: [],
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Generate an embedding for a query with comprehensive fallback mechanisms
 * @param {string} query - The query to generate an embedding for
 * @returns {Promise<Object>} Standardized result with embedding vector and metadata
 */
async function generateQueryEmbedding(query) {
  if (!embeddingsInterface || typeof embeddingsInterface.generate !== 'function') {
    logger.error('[SemanticContextManager] Embeddings interface is not available. Failing fast.');
    throw new Error('Embeddings interface is not available. Cannot generate embeddings.');
  }
  try {
    const embedding = await embeddingsInterface.generate(query);
    return { embedding, method: 'true-semantic-embeddings' };
  } catch (err) {
    logger.error('[SemanticContextManager] Failed to generate embedding:', err);
    throw err;
  }
}

/**
 * Process a file using semantic chunking
 * @param {string} filePath - Path to the file
 * @returns {Promise<Object>} Standardized result with chunks and metadata
 */
async function processFileWithSemanticChunker(filePath) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          chunks: [],
          metadata: {
            filePath,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    logger.info(`Processing file with semantic chunker: ${filePath}`);
    
    // Process file with semantic chunker
    const chunks = await semanticChunker.processFile(filePath, {
      MAX_CHUNK_SIZE: CONFIG.MAX_CHUNK_SIZE,
      OVERLAP_SIZE: CONFIG.OVERLAP_SIZE
    });
    
    // Format chunks for embedding system
    const formattedChunks = semanticChunker.formatChunks(chunks);
    
    logger.info(`Created ${formattedChunks.length} semantic chunks for ${filePath}`);
    return {
      success: true,
      chunks: formattedChunks,
      metadata: {
        filePath,
        timestamp: Date.now(),
        count: formattedChunks.length
      }
    };
  } catch (error) {
    logger.error(`Error processing file with semantic chunker: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Error processing file with semantic chunker', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      chunks: [],
      metadata: {
        filePath,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Search for context based on semantic similarity
 * @param {string} query - Query text
 * @param {Object} options - Search options
 * @returns {Promise<Object>} Standardized result with context results and metadata
 */
async function searchContext(query, options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    // Track metrics
    const startTime = Date.now();
    
    // Check for abort signal
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // Check if we need to reload embeddings and chunks
    if (embeddings.length === 0 || chunks.length === 0 || needsReload()) {
      logger.info('Loading embeddings and chunks');
      
      try {
        // Load embeddings using path utilities
        const embeddingsPath = pathUtils.normalize(CONFIG.embeddingsFile);
        if (!await pathUtils.exists(embeddingsPath)) {
          throw new Error(`Embeddings file not found: ${embeddingsPath}`);
        }
        
        // Read embeddings file
        const embeddingsData = await pathUtils.readFile(embeddingsPath);
        embeddings = embeddingsData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastEmbeddingsLoadTime = Date.now();
        
        // Load chunks using path utilities
        const chunksPath = pathUtils.normalize(CONFIG.chunksFile);
        if (!await pathUtils.exists(chunksPath)) {
          throw new Error(`Chunks file not found: ${chunksPath}`);
        }
        
        // Read chunks file
        const chunksData = await pathUtils.readFile(chunksPath);
        chunks = chunksData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastChunksLoadTime = Date.now();
        
        // Build corpus stats
        if (CONFIG.ENABLE_CORPUS_STATS) {
          corpusStats = await buildCorpusStats();
        }
        
        // Emit data loaded event
        eventBus.emit('context:data:loaded', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          embeddingsCount: embeddings.length,
          chunksCount: chunks.length,
          loadTime: Date.now() - startTime
        });
        
        logger.info(`Loaded ${embeddings.length} embeddings and ${chunks.length} chunks in ${Date.now() - startTime}ms`);
      } catch (error) {
        logger.error(`Failed to load embeddings or chunks: ${error.message}`);
        
        // Emit error event
        eventBus.emit('context:data:error', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          error: error.message
        });
        
        return {
          success: false,
          error: error.message,
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    // Set up options with standardized configuration access
    // Use a lower default similarity threshold to ensure more results
    const similarityThreshold = options.similarityThreshold || CONFIG.similarityThreshold || 0.15;
    const maxResults = options.maxResults || CONFIG.maxResults || 15; // Increase default max results
    const cacheKey = `${query}:${similarityThreshold}:${maxResults}`;
    
    // Check cache first
    if (queryCache.has(cacheKey)) {
      const cacheEntry = queryCache.get(cacheKey);
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // Only use cache if it's not too old (using configured TTL)
      if (cacheAge < CONFIG.queryCacheTtl) {
        logger.debug('Using cached context', { query, cacheAge: `${Math.round(cacheAge/1000)}s` });
        
        // Emit cache hit event
        eventBus.emit('context:cache:hit', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
          cacheAge
        });
        
        return {
          success: true,
          results: cacheEntry.results,
          metadata: {
            query,
            timestamp: Date.now(),
            count: cacheEntry.results.length,
            options: {
              similarityThreshold,
              maxResults
            }
          }
        };
      }
    }
    
    // Analyze query to determine boosting strategy
    const analysis = analyzeQuery(query);
    logger.debug('Query analysis', { analysis });
    
    // Check if operation has been aborted
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // Generate query embedding using standardized function
    const queryEmbedding = await generateQueryEmbedding(query);
    
    // Track similarity calculation time
    const similarityStartTime = Date.now();
    
    // Calculate similarity scores with standardized approach
    const results = embeddings.map((item, index) => {
      // Get corresponding chunk
      const chunk = chunks[index] || {};
      
      // Calculate cosine similarity using local embeddings interface
      let similarity;
      try {
        // Primary approach: use our local embeddings interface
        if (embeddingsInterface && typeof embeddingsInterface.cosineSimilarity === 'function') {
          similarity = embeddingsInterface.cosineSimilarity(
            queryEmbedding,
            item.embedding || item.vector // Support both embedding and vector keys
          );
        }
        // Fallback: use the module's cosineSimilarity function
        else if (typeof trueSemanticEmbeddings.cosineSimilarity === 'function') {
          similarity = trueSemanticEmbeddings.cosineSimilarity(
            queryEmbedding,
            item.embedding || item.vector // Support both embedding and vector keys
          );
        }
        else {
          // Final fallback: simple dot product calculation
          logger.error('No cosine similarity function available');
          throw new Error('No cosine similarity function available');
        }
      } catch (error) {
        logger.error(`Error calculating similarity: ${error.message}`);
        similarity = 0; // Default to zero similarity on error
      }
      
      // Apply intelligent boosting based on query analysis
      let boostedSimilarity = similarity;
      
      // Infer chunk type using standardized function
      const chunkType = inferChunkType(chunk);
      
      // Apply boosting based on query type and chunk type
      if (analysis.isCodeQuery && chunkType === 'code') {
        boostedSimilarity *= 1.3; // Boost code chunks for code queries
      } else if (analysis.isDocumentationQuery && chunkType === 'documentation') {
        boostedSimilarity *= 1.3; // Boost documentation for documentation queries
      } else if (analysis.isStructuralQuery && chunk.path && chunk.path.includes(analysis.targetFile)) {
        boostedSimilarity *= 1.5; // Boost chunks from the target file
      }
      
      // Emit similarity calculated event (for every 100th item to avoid event flood)
      if (index % 100 === 0) {
        eventBus.emit('context:similarity:calculated', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          chunkType,
          similarity: Math.round(similarity * 100) / 100,
          boostedSimilarity: Math.round(boostedSimilarity * 100) / 100
        });
      }
      
      return {
        id: chunk.chunk_id || `chunk_${index}`,
        path: chunk.file || item.file,
        content: chunk.content || item.content,
        text: chunk.text || item.text, // Support both content and text properties
        similarity: boostedSimilarity,
        originalSimilarity: similarity,
        type: chunkType
      };
    });
    
    // Sort by boosted similarity
    results.sort((a, b) => b.similarity - a.similarity);
    
    // Filter by similarity threshold
    const filteredResults = results.filter(item => item.similarity >= similarityThreshold);
    
    // Limit results
    const topResults = filteredResults.slice(0, maxResults);
    
    // Calculate similarity time
    const similarityTime = Date.now() - similarityStartTime;
    logger.debug(`Calculated similarity for ${embeddings.length} embeddings in ${similarityTime}ms`);
    
    // Add results to cache
    queryCache.set(cacheKey, {
      results: topResults,
      timestamp: Date.now()
    });
    
    // Emit cache miss event
    eventBus.emit('context:cache:miss', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
      resultCount: topResults.length,
      searchTime: Date.now() - startTime
    });
    
    return {
      success: true,
      results: topResults,
      metadata: {
        query,
        timestamp: Date.now(),
        count: topResults.length,
        searchTime: Date.now() - startTime,
        searchType: 'semantic',
        options: {
          similarityThreshold,
          maxResults
        }
      }
    };
  } catch (error) {
    logger.error(`Context search failed: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Context search failed', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      results: [],
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Process a file with the semantic chunker
 * @param {string} filePath - Path to the file
 * @param {Object} options - Processing options
 * @returns {Promise<Object>} Standardized result with chunks and metadata
 */
async function processFileWithSemanticChunker(filePath, options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          chunks: [],
          metadata: {
            filePath,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    // Verify file exists
    if (!await pathUtils.exists(filePath)) {
      logger.error(`File not found: ${filePath}`);
      return {
        success: false,
        error: `File not found: ${filePath}`,
        chunks: [],
        metadata: {
          filePath,
          timestamp: Date.now(),
          status: 'error'
        }
      };
    }
    
    // Read file content
    const fileContent = await pathUtils.readFile(filePath);
    
    // Get file extension
    const fileExt = pathUtils.getExtension(filePath);
    
    // Use semantic chunker to process the file
    const semanticChunker = require('../services/semantic-chunker');
    const chunks = await semanticChunker.createSemanticChunks(fileContent, {
      filePath,
      fileType: fileExt,
      ...options
    });
    
    logger.info(`Processed file ${filePath} with semantic chunker, generated ${chunks.length} chunks`);
    
    return {
      success: true,
      chunks,
      metadata: {
        filePath,
        timestamp: Date.now(),
        count: chunks.length,
        options
      }
    };
  } catch (error) {
    logger.error(`Failed to process file with semantic chunker: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Failed to process file with semantic chunker', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      chunks: [],
      metadata: {
        filePath,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Process multiple files with the semantic chunker
 * @param {Array} filePaths - Array of file paths
 * @param {Object} options - Processing options
 * @returns {Promise<Object>} Standardized result with chunks and metadata
 */
async function processFilesWithSemanticChunker(filePaths, options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          results: [],
          metadata: {
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    if (!Array.isArray(filePaths)) {
      logger.error('filePaths must be an array');
      return {
        success: false,
        error: 'filePaths must be an array',
        results: [],
        metadata: {
          timestamp: Date.now(),
          status: 'error'
        }
      };
    }
    
    // Process each file
    const results = [];
    const errors = [];
    
    for (const filePath of filePaths) {
      try {
        const result = await processFileWithSemanticChunker(filePath, options);
        results.push({
          filePath,
          success: result.success,
          chunks: result.chunks,
          error: result.error
        });
        
        if (!result.success) {
          errors.push({
            filePath,
            error: result.error
          });
        }
      } catch (error) {
        logger.error(`Error processing file ${filePath}: ${error.message}`);
        results.push({
          filePath,
          success: false,
          chunks: [],
          error: error.message
        });
        
        errors.push({
          filePath,
          error: error.message
        });
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    logger.info(`Processed ${filePaths.length} files with semantic chunker, ${successCount} successful, ${errors.length} errors`);
    
    return {
      success: errors.length === 0,
      results,
      errors: errors.length > 0 ? errors : null,
      metadata: {
        timestamp: Date.now(),
        totalFiles: filePaths.length,
        successCount,
        errorCount: errors.length,
        options
      }
    };
  } catch (error) {
    logger.error(`Failed to process files with semantic chunker: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Failed to process files with semantic chunker', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      results: [],
      metadata: {
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Invalidate the context cache
 * @param {Object} options - Cache invalidation options
 * @returns {Promise<Object>} Standardized result with invalidation status and metadata
 */
async function invalidateCache(options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          metadata: {
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    const startTime = Date.now();
    const cacheSize = queryCache.size;
    
    // Clear the cache
    queryCache.clear();
    
    logger.info(`Cache invalidated, cleared ${cacheSize} entries`);
    
    // Emit cache invalidated event
    eventBus.emit('context:cache:invalidated', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      cacheSize,
      options
    });
    
    return {
      success: true,
      metadata: {
        timestamp: Date.now(),
        entriesCleared: cacheSize,
        duration: Date.now() - startTime,
        options
      }
    };
  } catch (error) {
    logger.error(`Failed to invalidate cache: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Failed to invalidate cache', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      metadata: {
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * Generate an embedding for a query with comprehensive fallback mechanisms
 * @param {string} query - The query to generate an embedding for
 * @returns {Promise<Object>} Standardized result with embedding vector and metadata
 */
async function generateQueryEmbedding(query) {
  if (!embeddingsInterface || typeof embeddingsInterface.generate !== 'function') {
    logger.error('[SemanticContextManager] Embeddings interface is not available. Failing fast.');
    throw new Error('Embeddings interface is not available. Cannot generate embeddings.');
  }
  try {
    const embedding = await embeddingsInterface.generate(query);
    return { embedding, method: 'true-semantic-embeddings' };
  } catch (err) {
    logger.error('[SemanticContextManager] Failed to generate embedding:', err);
    throw err;
  }
  
  for (let i = 0; i < normalizedText.length; i++) {
    const charCode = normalizedText.charCodeAt(i);
    embedding[i % embedding.length] += charCode / 255;
  }
  
  // Normalize the embedding
  const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
  if (norm > 0) {
    for (let i = 0; i < embedding.length; i++) {
      embedding[i] /= norm;
    }
  }
  
  return embedding;
}

/**
 * Extract context from the current state
 * @param {Object} options - Extraction options
 * @returns {Promise<Object>} Standardized result with extracted context and metadata
 */
async function extractContext(options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Get current context
    const contextResult = await getCurrentContext(options);
    
    if (!contextResult.success) {
      logger.warn('Failed to extract context:', contextResult.error);
      return contextResult;
    }
    
    // Format the context for extraction
    const extractedContext = {
      content: contextResult.context,
      timestamp: Date.now(),
      metadata: {
        source: 'semantic-context-manager',
        boundary: await checkBoundaryProximity(),
        quality: await calculateContextQualityMetrics(contextResult.context, options)
      }
    };
    
    logger.info('Context extracted successfully');
    
    // Emit event
    eventBus.emit('context:extracted', {
      timestamp: Date.now(),
      size: JSON.stringify(extractedContext).length
    }, COMPONENT_NAME);
    
    return {
      success: true,
      context: extractedContext,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(extractedContext).length
      }
    };
  } catch (error) {
    logger.error(`Error extracting context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * Store context for later retrieval
 * @param {Object} context - Context to store
 * @param {Object} options - Storage options
 * @returns {Promise<Object>} Standardized result with storage status and metadata
 */
async function storeContext(context, options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Validate context
    if (!context) {
      return {
        success: false,
        error: 'No context provided for storage',
        metadata: { timestamp: Date.now() }
      };
    }
    
    // Prepare context for storage
    const contextToStore = {
      content: context,
      timestamp: Date.now(),
      metadata: {
        source: 'semantic-context-manager',
        boundary: await checkBoundaryProximity(),
        options
      }
    };
    
    // Store context using context preservation system
    const storageResult = await storeContextForBoundaryCrossing(contextToStore);
    
    if (!storageResult) {
      logger.warn('Failed to store context');
      return {
        success: false,
        error: 'Failed to store context',
        metadata: { timestamp: Date.now() }
      };
    }
    
    logger.info('Context stored successfully');
    
    // Emit event
    eventBus.emit('context:stored', {
      timestamp: Date.now(),
      size: JSON.stringify(contextToStore).length
    }, COMPONENT_NAME);
    
    return {
      success: true,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(contextToStore).length
      }
    };
  } catch (error) {
    logger.error(`Error storing context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * Get context quality metrics with enhanced boundary awareness
 * @param {Object} options - Options for metrics retrieval
 * @returns {Object} Context quality metrics
 */

  // Default status if session boundary manager is not available
  return {
    status: 'ok',
    percentage: 0,
    message: 'No session boundary manager available'
  };

/**
  const metrics = {
    overallQuality: 0.75, // Default quality score
    coherence: 0.8,
    relevance: 0.7,
    completeness: 0.75,
    boundaryResilience: 0.65, // How well context preserves across boundaries
    timestamp: Date.now()
  };
  
  // Add trend analysis if requested
  if (includeTrends) {
    metrics.trends = {
      qualityTrend: 'stable',
      coherenceTrend: 'improving',
      relevanceTrend: 'stable',
      boundaryResilienceTrend: 'improving'
    };
  }
  
  // Add user feedback metrics if requested
  if (includeUserFeedback) {
    metrics.userFeedback = {
      positiveResponses: 85, // Percentage
      negativeResponses: 15, // Percentage
      explicitFeedbackCount: 10,
      implicitFeedbackCount: 45
    };
  }
  
  // Add predictive metrics if requested
  if (includePredictions) {
    // Calculate boundary crossing predictions
    // Use the getBoundaryStatus function directly
    const boundaryStatus = getBoundaryStatus();
    
    metrics.predictions = {
      nextBoundaryQuality: metrics.boundaryResilience * metrics.overallQuality,
      confidenceScore: 0.8,
      preservationLikelihood: metrics.boundaryResilience,
      boundaryProximity: boundaryStatus.percentage || 0
    };
  }
  
  return metrics;
}

/**
 * Extract context from current session
 * @param {Object} options - Options for context extraction
 * @returns {Promise<Object>} Extracted context with standardized result format
 */
async function extractContext(options = {}) {
  if (!initialized) {
    logger.warn(`${COMPONENT_NAME} not initialized, cannot extract context`);
    return { success: false, error: 'Not initialized' };
  }

  try {
    // Get current context
    const currentContext = await getCurrentContext(options);
    
    if (!currentContext.success) {
      return currentContext; // Forward the error
    }
    
    // Enhance context with metadata
    const enhancedContext = {
      ...currentContext.context,
      metadata: {
        extractionTime: Date.now(),
        source: 'semantic-context-manager',
        sessionId: sessionBoundaryManager ? sessionBoundaryManager.getCurrentSession().id : 'unknown',
        quality: getContextQualityMetrics()
      }
    };
    
    logger.info('Context extracted successfully');
    
    return {
      success: true,
      context: enhancedContext,
      timestamp: Date.now()
    };
  } catch (error) {
    logger.error(`Error extracting context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      timestamp: Date.now()
    };
  }
}

/**
 * Store context for future retrieval
 * @param {Object} context - Context to store
 * @param {Object} options - Options for context storage
 * @returns {Promise<Object>} Storage result
 */
async function storeContext(context, options = {}) {
  if (!initialized) {
    logger.warn(`${COMPONENT_NAME} not initialized, cannot store context`);
    return { success: false, error: 'Not initialized' };
  }
  
  if (!context) {
    logger.warn('No context provided for storage');
    return { success: false, error: 'No context provided' };
  }
  
  try {
    // Generate embedding for context if not already present
    if (!context.embedding) {
      // Convert context to string if it's an object
      const contextString = typeof context === 'object' ? JSON.stringify(context) : context;
      
      // Generate embedding
      if (localSemanticEmbeddings && typeof localSemanticEmbeddings.createEmbedding === 'function') {
        context.embedding = await localSemanticEmbeddings.createEmbedding(contextString);
      }
    }
    
    // Add metadata if not present
    if (!context.metadata) {
      context.metadata = {
        storageTime: Date.now(),
        source: 'semantic-context-manager',
        sessionId: sessionBoundaryManager ? sessionBoundaryManager.getCurrentSession().id : 'unknown'
      };
    }
    
    // Store in memory cache
    const cacheKey = `context-${Date.now()}`;
    contextCache.set(cacheKey, context);
    
    // Trim cache if it exceeds max size
    if (contextCache.size > config.maxCacheSize) {
      // Remove oldest entries
      const keysToDelete = Array.from(contextCache.keys())
        .sort((a, b) => {
          const timeA = parseInt(a.split('-')[1]);
          const timeB = parseInt(b.split('-')[1]);
          return timeA - timeB;
        })
        .slice(0, contextCache.size - config.maxCacheSize);
      
      keysToDelete.forEach(key => contextCache.delete(key));
    }
    
    logger.info('Context stored successfully');
    
    return {
      success: true,
      cacheKey,
      timestamp: Date.now()
    };
  } catch (error) {
    logger.error(`Error storing context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      timestamp: Date.now()
    };
  }
}

/**
 * Get current context with intelligent selection and prioritization
 * @param {Object} options - Options for context retrieval
 * @returns {Promise<Object>} Current context with standardized result format
 */
async function getCurrentContext(options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Check boundary proximity for adaptive context selection
    const boundaryStatus = await checkBoundaryProximity();
    const isNearBoundary = boundaryStatus.status === 'warning' || boundaryStatus.status === 'critical';
    
    // Adjust options based on boundary proximity if adaptive selection is enabled
    const adaptiveOptions = { ...options };
    if (isNearBoundary && (options.adaptiveContextSelection !== false)) {
      adaptiveOptions.prioritizeRecentActivity = true;
      adaptiveOptions.maxContextSize = options.maxContextSize || Math.floor(CONFIG.maxResults * 0.7);
      logger.info('Adapting context selection due to boundary proximity');
    }
    
    // Perform semantic search to get relevant context
    const searchResult = await searchContext('', {
      maxResults: adaptiveOptions.maxContextSize || CONFIG.maxResults,
      includeMetadata: true
    });
    
    if (!searchResult.success) {
      logger.warn('Failed to retrieve context:', searchResult.error);
      return searchResult;
    }
    
    // Format and return the context
    const formattedContext = {
      items: searchResult.results,
      metadata: {
        timestamp: Date.now(),
        boundaryStatus: boundaryStatus.status,
        adaptiveSelection: isNearBoundary && (options.adaptiveContextSelection !== false)
      }
    };
    
    return {
      success: true,
      context: formattedContext,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(formattedContext).length
      }
    };
  } catch (error) {
    logger.error(`Error getting current context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * STANDARDIZED INTERFACE
 * 
 * This module exports a standardized interface for semantic context operations.
 * All components should use these functions to interact with the semantic context system.
 * 
 * This interface follows the standardized patterns defined in LEO_STANDARDIZATION.md
 */


const metrics = {
  overallQuality: 0,
  coverage: 0,
  relevance: 0,
  recency: 0,
  diversity: 0,
  coherence: 0,
  completeness: 0,
  boundaryResilience: 0,
  userAlignmentScore: 0
};

// Calculate coverage (how much of the relevant context is included)
let coverageScore = 0;
let coverageWeights = {
  semanticMemory: 0.3,
  developmentHistory: 0.2,
  recentQueries: 0.15,
  activeEmbeddings: 0.25,
  activityFocus: 0.1
};

if (context.semanticMemory && context.semanticMemory.length > 0) {
  // Scale by both quantity and quality of memory items
  const qualityFactor = Math.min(1, context.semanticMemory.length / 10); // Scale up to 10 items
  const highPriorityRatio = context.semanticMemory.filter(item => 
    item.priority === 'critical' || item.priority === 'high'
  ).length / context.semanticMemory.length;
  
  coverageScore += coverageWeights.semanticMemory * qualityFactor * (0.5 + 0.5 * highPriorityRatio);
}

if (context.developmentHistory && context.developmentHistory.length > 0) {
  // Scale by recency and relevance of history items
  const recencyFactor = Math.min(1, context.developmentHistory.length / 5); // Scale up to 5 items
  coverageScore += coverageWeights.developmentHistory * recencyFactor;
}

if (context.recentQueries && context.recentQueries.length > 0) {
  coverageScore += coverageWeights.recentQueries * Math.min(1, context.recentQueries.length / 3);
}

if (context.activeEmbeddings && Object.keys(context.activeEmbeddings).length > 0) {
  coverageScore += coverageWeights.activeEmbeddings;
}

if (context.activityFocus && Object.keys(context.activityFocus).length > 0) {
  coverageScore += coverageWeights.activityFocus;
}

metrics.coverage = Math.min(coverageScore, 1.0);

// Calculate relevance (how relevant the included context is to current activity)
let relevanceScore = 0;
let relevanceItemCount = 0;

// Check semantic memory relevance with sophisticated scoring
if (context.semanticMemory && context.semanticMemory.length > 0) {
  // Weight items by priority
  const priorityWeights = {
    critical: 1.0,
    high: 0.8,
    medium: 0.5,
    low: 0.2
  };
  
  const memoryRelevance = context.semanticMemory.reduce((sum, item) => {
    const priorityWeight = priorityWeights[item.priority] || 0.5;
    return sum + (item.relevanceScore || 0.5) * priorityWeight;
  }, 0) / context.semanticMemory.length;
  
  relevanceScore += memoryRelevance;
  relevanceItemCount++;
}

// Check development history relevance
if (context.developmentHistory && context.developmentHistory.length > 0) {
  // Calculate relevance based on recency and activity focus
  const historyRelevance = 0.7; // Simplified for now, could be more sophisticated
  relevanceScore += historyRelevance;
  relevanceItemCount++;
}

// Factor in activity focus if available
if (context.activityFocus) {
  const activityRelevance = 0.9; // High relevance for current activity focus
  relevanceScore += activityRelevance;
  relevanceItemCount++;
}

metrics.relevance = relevanceItemCount > 0 ? relevanceScore / relevanceItemCount : 0;

// Calculate recency (how recent the context elements are)
let recencyScore = 0;
const now = Date.now();

if (context.semanticMemory && context.semanticMemory.length > 0) {
  // Calculate average age of memory items in hours
  const avgAgeHours = context.semanticMemory.reduce((sum, item) => {
    const timestamp = item.timestamp || now;
    const ageHours = (now - timestamp) / (1000 * 60 * 60);
    return sum + ageHours;
  }, 0) / context.semanticMemory.length;
  
  // Convert to recency score (newer = higher score)
  // Assume 24 hours is the threshold for "recent"
  recencyScore = Math.max(0, 1 - (avgAgeHours / 24));
}

metrics.recency = recencyScore;

// Calculate diversity (how diverse the context elements are)
let diversityScore = 0;

if (context.semanticMemory && context.semanticMemory.length > 0) {
  // Count unique types/categories of memory items
  const uniqueTypes = new Set();
  context.semanticMemory.forEach(item => {
    if (item.type) uniqueTypes.add(item.type);
  });
  
module.exports = {
  // Core functions
  initialize,
  isInitialized: () => isInitialized,
  getStatus,
  
  // Context operations
  searchContext,
  getCurrentContext,
  injectContext,
  generateEnhancedPrompt,
  extractContext,
  storeContext,
  
  /**
   * Get the embeddings interface with initialization checks
   * @returns {Object} The initialized embeddings interface
   * @throws {Error} If the embeddings interface is not available or fails to initialize
   */
  async getEmbeddingsInterface() {
    // If no embeddings interface is available, try to create a fallback
    if (!embeddingsInterface) {
      try {
        logger.warn('No embeddings interface available, creating fallback');
        embeddingsInterface = createFallbackEmbeddingsInterface();
        module.exports.embeddingsInterface = embeddingsInterface;
      } catch (error) {
        logger.error('Failed to create fallback embeddings interface:', error);
        throw new Error(`Embeddings interface not available: ${error.message}`);
      }
    }

    // Check if the interface needs initialization
    if (embeddingsInterface.isInitialized && !embeddingsInterface.isInitialized()) {
      try {
        logger.info('Initializing embeddings interface on demand');
        if (typeof embeddingsInterface.initialize === 'function') {
  await embeddingsInterface.initialize();
}
        logger.info('Embeddings interface initialized successfully');
      } catch (initError) {
        logger.error('Failed to initialize embeddings interface:', initError);
        throw new Error(`Failed to initialize embeddings: ${initError.message}`);
      }
    }

    return embeddingsInterface;
  },
  
  // File processing
  processFileWithSemanticChunker,
  processFilesWithSemanticChunker,
  
  // Cache management
  invalidateCache,
  
  // Token boundary awareness
  getBoundaryStatus() {
    if (!isInitialized || !boundaryAwarenessEnabled) {
      return { status: 'unknown', percentage: 0, enabled: false };
    }
    try {
      // Get boundary status from session boundary manager if available
      if (sessionBoundaryManager && sessionBoundaryManager.isInitialized) {
        const boundaryStatus = sessionBoundaryManager.getBoundaryProximity();
        return {
          ...boundaryStatus,
          isPreservingContext: contextPreservationState.isPreserving,
          enabled: true
        };
      }
      // Return default status if session boundary manager not available
      return {
        status: lastBoundaryStatus || 'unknown',
        percentage: 0,
        isPreservingContext: contextPreservationState.isPreserving,
        enabled: boundaryAwarenessEnabled
      };
    } catch (error) {
      logger.error(`Error getting boundary status: ${error.message}`);
      return { status: 'error', percentage: 0, enabled: false, error: error.message };
    }
  },
  

  
  // Context retrieval
  getCurrentContext,
  
  // Activity focus determination
  determineUserActivityFocus,
  
  // Domain detection
  determinePrimaryDomain,
  
  // Component extraction
  extractActiveComponents,
  
  // Keyword extraction
  extractKeywords,
  
  // Task inference
  inferCurrentTask,
  
  // Semantic memory retrieval
  getSemanticMemoryWithFiltering,
  
  // Development history retrieval
  getDevelopmentHistory,
  
  // Recent queries retrieval
  getRecentQueries,
  
  // Active embeddings retrieval
  getActiveEmbeddings,
  
  // Context prioritization
  prioritizeContextElements,
  
  // Priority level calculation
  getPriorityLevel,
  
  // Context quality metrics calculation
  calculateContextQualityMetrics
};
    const metrics = {
      overallQuality: 0,
      coverage: 0,
      relevance: 0,
      recency: 0,
      diversity: 0,
      coherence: 0,
      completeness: 0,
      boundaryResilience: 0,
      userAlignmentScore: 0
    };
    
    // Calculate coverage (how much of the relevant context is included)
    let coverageScore = 0;
    let coverageWeights = {
      semanticMemory: 0.3,
      developmentHistory: 0.2,
      recentQueries: 0.15,
      activeEmbeddings: 0.25,
      activityFocus: 0.1
    };
    
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Scale by both quantity and quality of memory items
      const qualityFactor = Math.min(1, context.semanticMemory.length / 10); // Scale up to 10 items
      const highPriorityRatio = context.semanticMemory.filter(item => 
        item.priority === 'critical' || item.priority === 'high'
      ).length / context.semanticMemory.length;
      
      coverageScore += coverageWeights.semanticMemory * qualityFactor * (0.5 + 0.5 * highPriorityRatio);
    }
    
    if (context.developmentHistory && context.developmentHistory.length > 0) {
      // Scale by recency and relevance of history items
      const recencyFactor = Math.min(1, context.developmentHistory.length / 5); // Scale up to 5 items
      coverageScore += coverageWeights.developmentHistory * recencyFactor;
    }
    
    if (context.recentQueries && context.recentQueries.length > 0) {
      coverageScore += coverageWeights.recentQueries * Math.min(1, context.recentQueries.length / 3);
    }
    
    if (context.activeEmbeddings && Object.keys(context.activeEmbeddings).length > 0) {
      coverageScore += coverageWeights.activeEmbeddings;
    }
    
    if (context.activityFocus && Object.keys(context.activityFocus).length > 0) {
      coverageScore += coverageWeights.activityFocus;
    }
    
    metrics.coverage = Math.min(coverageScore, 1.0);
    
    // Calculate relevance (how relevant the included context is to current activity)
    let relevanceScore = 0;
    let relevanceItemCount = 0;
    
    // Check semantic memory relevance with sophisticated scoring
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Weight items by priority
      const priorityWeights = {
        critical: 1.0,
        high: 0.8,
        medium: 0.5,
        low: 0.2
      };
      
      const memoryRelevance = context.semanticMemory.reduce((sum, item) => {
        const priorityWeight = priorityWeights[item.priority] || 0.5;
        return sum + (item.relevanceScore || 0.5) * priorityWeight;
      }, 0) / context.semanticMemory.length;
      
      relevanceScore += memoryRelevance;
      relevanceItemCount++;
    }
    
    // Check development history relevance
    if (context.developmentHistory && context.developmentHistory.length > 0) {
      // Calculate relevance based on recency and activity focus
      const historyRelevance = 0.7; // Simplified for now, could be more sophisticated
      relevanceScore += historyRelevance;
      relevanceItemCount++;
    }
    
    // Factor in activity focus if available
    if (context.activityFocus) {
      const activityRelevance = 0.9; // High relevance for current activity focus
      relevanceScore += activityRelevance;
      relevanceItemCount++;
    }
    
    metrics.relevance = relevanceItemCount > 0 ? relevanceScore / relevanceItemCount : 0;
    
    // Calculate recency (how recent the context elements are)
    let recencyScore = 0;
    const now = Date.now();
    
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Calculate average age of memory items in hours
      const avgAgeHours = context.semanticMemory.reduce((sum, item) => {
        const timestamp = item.timestamp || now;
        const ageHours = (now - timestamp) / (1000 * 60 * 60);
        return sum + ageHours;
      }, 0) / context.semanticMemory.length;
      
      // Convert to recency score (newer = higher score)
      // Assume 24 hours is the threshold for "recent"
      recencyScore = Math.max(0, 1 - (avgAgeHours / 24));
    }
    
    metrics.recency = recencyScore;
    
    // Calculate diversity (how diverse the context elements are)
    let diversityScore = 0;
    
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Count unique types/categories of memory items
      const uniqueTypes = new Set();
      context.semanticMemory.forEach(item => {
        if (item.type) uniqueTypes.add(item.type);
      });
      
      // Score based on diversity of types
      diversityScore = Math.min(1, uniqueTypes.size / 5); // Scale up to 5 unique types
    }
    
    metrics.diversity = diversityScore;
    
    // Calculate coherence (how well the context elements fit together)
    let coherenceScore = 0;
    
    if (context.semanticMemory && context.semanticMemory.length > 2) {
      // Simplified coherence calculation - could be more sophisticated
      // Higher relevance scores generally indicate better coherence
      coherenceScore = metrics.relevance * 0.8;
    }
    
    metrics.coherence = coherenceScore;
    
    // Calculate completeness (how complete the context is for the current task)
    metrics.completeness = (metrics.coverage + metrics.relevance) / 2;
    
    // Calculate boundary resilience (how well the context will survive a token boundary)
    if (includeBoundaryProximity) {
      // Higher quality contexts are more resilient to boundary crossings
      metrics.boundaryResilience = (
        metrics.relevance * 0.4 +
        metrics.coherence * 0.3 +
        metrics.completeness * 0.3
      );
    } else {
      metrics.boundaryResilience = 0.5; // Default value when not considering boundaries
    }
    
    // User alignment score - how well the context aligns with user feedback
    // This would ideally use actual user feedback data
  
  /**
   * Get context quality metrics with enhanced boundary awareness
   * This function provides access to sophisticated context quality metrics
   * for token boundary awareness and context preservation
   * @param {Object} [options] - Options for metrics retrieval
   * @param {boolean} [options.includeTrends=true] - Whether to include trend analysis
   * @param {boolean} [options.includeUserFeedback=true] - Whether to include user feedback metrics
   * @param {boolean} [options.includePredictions=true] - Whether to include predictive metrics
   * @returns {Object} Comprehensive context quality metrics with boundary awareness
   */
const getContextQualityMetrics = (options = {}) => {
    const {
      includeTrends = true,
      includeUserFeedback = true,
      includePredictions = true
    } = options;
    
    // Get base metrics from last calculation or defaults
    const baseMetrics = this.lastContextQualityMetrics || {
      overallQuality: 0.5, // Default to medium quality
      coverage: 0.5,
      relevance: 0.5,
      recency: 0.5,
      diversity: 0.5,
      coherence: 0.5,
      completeness: 0.5,
      boundaryResilience: 0.5,
      userAlignmentScore: 0.5
    };
    
    // Start with base metrics
    const metrics = { ...baseMetrics };
    
    // Add timestamp for tracking
    metrics.timestamp = Date.now();
    
    // Add trend analysis if requested and history available
    if (includeTrends && this.contextQualityHistory && this.contextQualityHistory.length > 0) {
      // Calculate trends based on historical data
      const historyWindow = this.contextQualityHistory.slice(-5); // Last 5 measurements
      
      // Calculate simple trend direction and magnitude
      const oldestQuality = historyWindow[0].overallQuality;
      const newestQuality = historyWindow[historyWindow.length - 1].overallQuality;
      const qualityDelta = newestQuality - oldestQuality;
      
      metrics.trends = {
        direction: qualityDelta > 0.05 ? 'improving' : (qualityDelta < -0.05 ? 'declining' : 'stable'),
        magnitude: Math.abs(qualityDelta),
        historyAvailable: true,
        dataPoints: historyWindow.length
      };
    } else {
      metrics.trends = {
        direction: 'stable',
        magnitude: 0,
        historyAvailable: false
      };
    }
    
    // Add user feedback metrics if available
    if (includeUserFeedback) {
      metrics.userFeedback = {
        // This would ideally come from actual user feedback data
        alignmentScore: 0.85,
        satisfactionScore: 0.7,
        explicitFeedbackAvailable: false,
        implicitFeedbackAvailable: true
      };
    }
    
    // Add predictive metrics if requested
    if (includePredictions) {
      // Calculate boundary crossing predictions
      // Use the getBoundaryStatus function directly
      const boundaryStatus = getBoundaryStatus();
      
      metrics.predictions = {
        nextBoundaryQuality: metrics.boundaryResilience * metrics.overallQuality,
        confidenceScore: 0.8,
        preservationLikelihood: metrics.boundaryResilience,
        boundaryProximity: boundaryStatus.percentage || 0
      };
    }
    
    return metrics;
}
  
  /**
   * Store context for boundary crossing
   * @param {Object} context - Context to store
   * @returns {Promise<boolean>} Success status
   * @private
   */
  const storeContextForBoundaryCrossing = async function(context) {
    try {
      // Get storage path
      const storagePath = path.join(CONFIG.CONTEXT_STORAGE_PATH, 'boundary-crossings');
      
      // Ensure directory exists
      await fsPromises.mkdir(storagePath, { recursive: true });
      
      // Generate filename with timestamp and session ID
      const sessionId = context.sessionId || 'unknown-session';
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `context-${sessionId}-${timestamp}.json`;
      
      // Write context to file
      await fsPromises.writeFile(
        path.join(storagePath, filename),
        JSON.stringify(context, null, 2),
        'utf8'
      );
      
      // Store reference to latest context file
      contextPreservationState.latestContextFile = filename;
      
      return true;
    } catch (error) {
      logger.error(`Error storing context for boundary crossing: ${error.message}`);
      throw error;
    }
  };

    
async function restoreContextAfterBoundaryCrossing(savedContext = null) {
  try {
    // Update restoration state
    const restorationStartTime = Date.now();
    
    // Emit event to notify of restoration start
    eventBus.emit('semantic-context-manager:restoration-start', {
      timestamp: restorationStartTime
    });
    
    // Get latest context file
    const storagePath = path.join(CONFIG.CONTEXT_STORAGE_PATH, 'boundary-crossings');
    let contextFile;
    
    if (contextPreservationState.latestContextFile) {
      // Use the known latest context file if available
      contextFile = contextPreservationState.latestContextFile;
    } else {
      // Find the latest context file
      const files = await fsPromises.readdir(storagePath);
      const contextFiles = files.filter(file => file.startsWith('context-') && file.endsWith('.json'));
      
      if (contextFiles.length === 0) {
        contextFile = null;
      } else {
        contextFile = contextFiles[0];
      }
    }
    
    if (contextFile) {
      // Read and parse context file
      const contextData = JSON.parse(
        await fsPromises.readFile(path.join(storagePath, contextFile), 'utf8')
      );
      
      // Restore context
      if (contextData.semanticContext) {
        // Restore semantic context
        await restoreSemanticContext(contextData.semanticContext);
      }
      
      // Update restoration state
      const restorationEndTime = Date.now();
      
      // Emit event to notify of successful restoration
      eventBus.emit('semantic-context-manager:restoration-success', {
        timestamp: restorationEndTime,
        duration: restorationEndTime - restorationStartTime,
        contextFile
      });
      
      logger.info(`Context successfully restored after boundary crossing in ${restorationEndTime - restorationStartTime}ms`);
      
      return {
        success: true,
        timestamp: restorationEndTime,
        duration: restorationEndTime - restorationStartTime,
        contextFile
      };
    } 
    } catch (error) {
      // Emit event to notify of failed restoration
      eventBus.emit('semantic-context-manager:restoration-failure', {
        timestamp: Date.now(),
        error: error.message
      });
      
      logger.error(`Error restoring context after boundary crossing: ${error.message}`);
      
      return {
        success: false,
        error: error.message,
        timestamp: Date.now()
      };
    }
  }
  
  /**
   * Restore semantic context from saved context
   * @param {Object} semanticContext - Semantic context to restore
   * @returns {Promise<boolean>} Success status
   */
const restoreSemanticContext = async function(semanticContext) {
  try {
    // Restore recent queries if available
    if (semanticContext.recentQueries && Array.isArray(semanticContext.recentQueries)) {
      const recentQueries = [...semanticContext.recentQueries];
      // Store the queries in the appropriate service
    }
    // Restore active embeddings if available
    if (semanticContext.activeEmbeddings) {
      // Implementation depends on embeddings module structure
      // This is a placeholder for actual implementation
      logger.info('Restored active embeddings from preserved context');
    }
    return true;
  } catch (error) {
    logger.error(`Error restoring semantic context: ${error.message}`);
    throw error;
  }
};

const preserveContext = async function(force = false) {
  if (!boundaryAwarenessEnabled) {
    logger.warn('Token boundary awareness is disabled');
    return { success: false, error: 'Token boundary awareness is disabled' };
  }
      
  try {
    const preserved = await preserveContextForBoundaryCrossing(force);
    return {
      success: preserved,
      data: preserved ? {
        boundaryId: contextPreservationState.boundaryId,
        timestamp: contextPreservationState.preservationTimestamp
      } : null,
      error: preserved ? null : 'Failed to preserve context'
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

const restoreContext = async function(savedContext = null) {
  if (!boundaryAwarenessEnabled) {
    logger.warn('Token boundary awareness is disabled');
    return { success: false, error: 'Token boundary awareness is disabled' };
  }
      
  try {
    const restored = await restoreContextAfterBoundaryCrossing(savedContext);
    return {
      success: restored.success,
      data: restored.success ? {
        boundaryId: contextPreservationState.boundaryId,
        originalTimestamp: contextPreservationState.preservationTimestamp,
        restorationTimestamp: Date.now()
      } : null,
      error: restored.success ? null : restored.error
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

const getStatus = function() {
  return {
    isInitialized: getIsInitialized(),
    cacheStats: getCacheStats(),
    boundaryAwareness: {
      enabled: boundaryAwarenessEnabled,
      status: lastBoundaryStatus,
      contextPreservation: contextPreservationState.isPreserving
    }
  };
};

const semanticContextManager = {
  preserveContextForBoundaryCrossing,
  restoreContextAfterBoundaryCrossing,
  restoreSemanticContext,
  preserveContext,
  restoreContext,
  isInitialized,
  getStatus
};

module.exports = semanticContextManager;
