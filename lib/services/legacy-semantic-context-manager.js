/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
async function storeContext(context, options = {}) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
async function processFileWithSemanticChunker(filePath) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
async function processFilesWithSemanticChunker(filePaths) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
function invalidateCache() { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
function getBoundaryStatus() { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
function preserveContextForBoundaryCrossing(context) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
function restoreContextAfterBoundaryCrossing(savedContext) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
function restoreSemanticContext(semanticContext) { /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
 ... */ }
// Add other modern modularized APIs as needed

const semanticContextManager = {
  // Core functions
  initialize,
  isInitialized,
  getStatus,
  searchContext,
  getCurrentContext,
  injectContext,
  extractContext,
  storeContext,
  processFileWithSemanticChunker,
  processFilesWithSemanticChunker,
  invalidateCache,
  getBoundaryStatus,
  preserveContextForBoundaryCrossing,
  restoreContextAfterBoundaryCrossing,
  restoreSemanticContext,
  prioritizeContextElements,
  inferChunkType,
  mapAndEnrichChunks,
  filterChunksByType,
  postProcessChunks,
  calculateContextQualityMetrics,
  setEmbeddingsService,
  // Add other valid, modern APIs here as needed
};

module.exports = semanticContextManager;

// Token boundary awareness state
let boundaryAwarenessEnabled = true;
let lastBoundaryStatus = 'unknown';
let contextPreservationState = {
  isPreserving: false,
  lastPreservedContext: null,
  preservationTimestamp: 0,
  boundaryId: null
};


// Component name for event and config subscriptions
const COMPONENT_NAME = 'semantic-context-manager';

// Configuration object - using standardized access patterns
let CONFIG = {};

// Initialize configuration with standardized property paths
function initializeConfig() {
  CONFIG = {
    // Context retrieval settings
    similarityThreshold: configService.getConfig('contextManager.minSimilarityThreshold', 0.2),
    maxResults: configService.getConfig('contextManager.maxContextItems', 10),
    ENABLE_CORPUS_STATS: configService.getConfig('contextManager.enableCorpusStats', true),
    
    // Cache settings
    QUERY_CACHE_SIZE: configService.getConfig('contextManager.maxCacheItems', 1000),
    QUERY_CACHE_TTL: configService.getConfig('contextManager.cacheExpiration', 3600) * 1000,
    
    // Chunking settings
    USE_SEMANTIC_CHUNKER: configService.getConfig('chunking.useSemanticChunker', true),
    MAX_CHUNK_SIZE: configService.getConfig('chunking.maxChunkSize', 1000),
    OVERLAP_SIZE: configService.getConfig('chunking.chunkOverlap', 50),
    
    // Embedding settings
    EMBEDDING_DIMENSIONS: configService.getConfig('embedding.dimensions', 384),
    
    // File paths (using standardized property paths)
    embeddingsFile: configService.getConfig('paths.embeddings', pathUtils.join(process.cwd(), 'data', 'embeddings.jsonl')),
    chunksFile: configService.getConfig('paths.chunks', pathUtils.join(process.cwd(), 'data', 'chunks.jsonl')),
    cacheDir: configService.getConfig('paths.cache', pathUtils.join(process.cwd(), 'data', 'cache'))
  };
  
  logger.info('Configuration initialized', { 
    maxResults: CONFIG.maxResults,
    useSemanticChunker: CONFIG.USE_SEMANTIC_CHUNKER,
    embeddingDimensions: CONFIG.EMBEDDING_DIMENSIONS
  });
}

// Initialize configuration
initializeConfig();

// Subscribe to configuration changes
configService.subscribe(COMPONENT_NAME, (event, data) => {
  if (event === 'updated') {
    logger.info('Configuration updated, reinitializing');
    initializeConfig();
  }
});

// MIGRATION: Cache logic now uses injected cacheService, not local queryCache/cacheStats
// MIGRATION: cacheService must be injected for all cache operations
let cacheService = null; // Set by DI or at module init
function setCacheService(service) { cacheService = service; }

// MIGRATION: Remove legacy direct embedding arrays; all embedding ops via service
let chunks = [];
let embeddings = [];
// getCacheStats removed; use cacheService.getCacheStats()

// Subscribe to relevant events
eventBus.on('file:changed', handleFileChanged, COMPONENT_NAME);
eventBus.on('file:deleted', handleFileDeleted, COMPONENT_NAME);
eventBus.on('cache:invalidated', handleCacheInvalidated, COMPONENT_NAME);

// Subscribe to boundary health events for proactive context preservation
eventBus.on('boundary-health:status', handleBoundaryHealthStatus, COMPONENT_NAME);
eventBus.on('boundary-health:critical-threshold', handleCriticalBoundaryThreshold, COMPONENT_NAME);

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Handle file changed event
 * @param {Object} data - Event data
 * @private
 */
function handleFileChanged(data) {
  if (data && data.path) {
    invalidateCache(data.path);
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Handle file deleted event
 * @param {Object} data - Event data
 * @private
 */
function handleFileDeleted(data) {
  if (data && data.path) {
    invalidateCache(data.path);
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Handle cache invalidated event
 * @param {Object} data - Event data
 * @private
 */
function handleCacheInvalidated(data) {
  try {
    if (data && data.type === 'all') {
      logger.info('Invalidating all caches due to global cache invalidation event');
      // MIGRATION: Use cacheService.invalidateCache()
      if (cacheService) {
        cacheService.invalidateCache({ type: 'all' });
      }
    } else if (data && data.type === 'query') {
      logger.info('Invalidating query cache due to query cache invalidation event');
      // MIGRATION: Use cacheService.invalidateCache()
      if (cacheService) {
        cacheService.invalidateCache({ type: 'query' });
      }
    }
  } catch (error) {
    logger.error(`Error handling cache invalidation event: ${error.message}`);
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Handle boundary health status event for proactive context preservation
 * @param {Object} data - Boundary health status data
 * @private
 */
function handleBoundaryHealthStatus(data) {
  // Only take action if boundary awareness is enabled
  if (!boundaryAwarenessEnabled) {
    return;
  }
  
  try {
    // Update last boundary status
    lastBoundaryStatus = data.boundaryStatus;
    
    // Take proactive action based on boundary status
    if (data.boundaryStatus === 'warning' && !contextPreservationState.isPreserving) {
      // Start preparing for context preservation when we get a warning
      logger.info('Boundary warning detected, preparing for proactive context preservation');
      
      // Begin background context preservation without disrupting the user
      preserveContextForBoundaryCrossing(false).catch(error => {
        logger.warn(`Error in proactive context preservation: ${error.message}`);
      });
    }
  } catch (error) {
    logger.warn(`Error handling boundary health status: ${error.message}`);
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Handle critical boundary threshold event for immediate context preservation
 * @param {Object} data - Critical boundary threshold data
 * @private
 */
function handleCriticalBoundaryThreshold(data) {
  // Only take action if boundary awareness is enabled
  if (!boundaryAwarenessEnabled) {
    return;
  }
  
  try {
    if (data.requiresAction) {
      logger.warn('Critical boundary threshold detected, immediate context preservation required');
      
      // Force context preservation
      preserveContextForBoundaryCrossing(true).catch(error => {
        logger.error(`Error in critical context preservation: ${error.message}`);
        
        // Emit error event
        eventBus.emit('semantic-context-manager:preservation-failure', {
          error: error.message,
          timestamp: Date.now()
        });
      });
    }
  } catch (error) {
    logger.error(`Error handling critical boundary threshold: ${error.message}`);
  }
}

let corpusStats = {};
let lastEmbeddingsLoadTime = 0;
let lastChunksLoadTime = 0;
// isInitialized is declared at the top of the file

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Check if embeddings and chunks need to be reloaded
 * @returns {boolean} True if reload is needed
 * @private
 */
function needsReload() {
  // Check file modification times
  const embeddingsPath = pathUtils.normalize(CONFIG.embeddingsFile);
  const chunksPath = pathUtils.normalize(CONFIG.chunksFile);
  
  try {
    const embeddingsStats = fs.statSync(embeddingsPath);
    const chunksStats = fs.statSync(chunksPath);
    
    const embeddingsModTime = embeddingsStats.mtimeMs;
    const chunksModTime = chunksStats.mtimeMs;
    
    // Reload if files have been modified since last load
    if (embeddingsModTime > lastEmbeddingsLoadTime || chunksModTime > lastChunksLoadTime) {
      logger.info('Embeddings or chunks files have been modified, reload needed');
      return true;
    }
    
    // Reload if we have no data
    if (embeddings.length === 0 || chunks.length === 0) {
      logger.info('No embeddings or chunks loaded, reload needed');
      return true;
    }
    
    // Reload if it's been more than 1 hour since last load
    const oneHour = 60 * 60 * 1000;
    if (Date.now() - lastEmbeddingsLoadTime > oneHour || Date.now() - lastChunksLoadTime > oneHour) {
      logger.info('More than 1 hour since last load, reload needed');
      return true;
    }
    
    return false;
  } catch (error) {
    logger.warn(`Error checking if reload is needed: ${error.message}`);
    return true; // Reload on error to be safe
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Build corpus statistics for improved relevance scoring
 * @returns {Promise<Object>} Corpus statistics
 * @private
 */
async function buildCorpusStats() {
  try {
    logger.info('Building corpus statistics...');
    
    const startTime = Date.now();
    const stats = {
      terms: {},
      documentCount: chunks.length,
      averageDocumentLength: 0,
      totalTerms: 0
    };
    
    // Calculate term frequencies and document frequencies
    let totalLength = 0;
    
    for (const chunk of chunks) {
      const content = chunk.content || chunk.text || '';
      const terms = content.toLowerCase().split(/\W+/).filter(term => term.length > 1);
      
      totalLength += terms.length;
      
      // Count unique terms in this document
      const uniqueTerms = new Set(terms);
      
      for (const term of uniqueTerms) {
        if (!stats.terms[term]) {
          stats.terms[term] = {
            documentFrequency: 1,
            termFrequency: 0
          };
        } else {
          stats.terms[term].documentFrequency += 1;
        }
      }
      
      // Count term frequencies
      for (const term of terms) {
        if (stats.terms[term]) {
          stats.terms[term].termFrequency += 1;
        }
      }
    }
    
    // Calculate average document length
    stats.averageDocumentLength = totalLength / chunks.length;
    stats.totalTerms = Object.keys(stats.terms).length;
    
    // Save corpus stats to cache
    const statsPath = path.join(CONFIG.cacheDir, 'corpus-stats.json');
    
    // Use promisified fs.writeFile or handle callback properly
    await new Promise((resolve, reject) => {
      fs.writeFile(statsPath, JSON.stringify(stats, null, 2), (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
    
    logger.info(`Built corpus statistics with ${stats.totalTerms} terms and ${stats.documentCount} documents in ${Date.now() - startTime}ms`);
    
    return stats;
  } catch (error) {
    logger.error(`Failed to build corpus statistics: ${error.message}`);
    return {
      terms: {},
      documentCount: 0,
      averageDocumentLength: 0,
      totalTerms: 0
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Initialize the semantic context manager
 * @param {Object} options - Initialization options
 * @param {Object} [options.embeddingsInterface] - Optional embeddings interface to use directly
 * @returns {Promise<boolean>} - Success status
 */
async function initialize(options = {}) {
  try {
    // Emit initialization start event
    eventBus.emit('semantic-context-manager:initializing', {
      timestamp: Date.now()
    });
    
    // Prevent duplicate initialization
    if (isInitialized) {
      logger.info('Semantic context manager already initialized');
      
      // Emit already initialized event
      eventBus.emit('semantic-context-manager:initialized', {
        success: true,
        status: 'already-initialized',
        timestamp: Date.now()
      });
      
      return true;
    }

    logger.info('Initializing semantic context manager with local embeddings...');

    // Initialize configuration
    // Check if files exist
    const embeddingsExists = fs.existsSync(CONFIG.embeddingsFile);
    const chunksExists = fs.existsSync(CONFIG.chunksFile);
    
    if (!embeddingsExists) {
      logger.warn(`Embeddings file not found: ${CONFIG.embeddingsFile}`);
    }
    
    if (!chunksExists) {
      logger.warn(`Chunks file not found: ${CONFIG.chunksFile}`);
    }
    
    // Create cache directory if it doesn't exist
    if (!fs.existsSync(CONFIG.cacheDir)) {
      logger.info(`Creating cache directory: ${CONFIG.cacheDir}`);
      fs.mkdirSync(CONFIG.cacheDir, { recursive: true });
    }
    
    // Initialize the local embeddings interface
    if (embeddingsInterface) {
      logger.info('Initializing local embeddings interface...');
      if (typeof embeddingsInterface.initialize === 'function') {
        await embeddingsInterface.initialize();
      }
      logger.info('Local embeddings interface initialized successfully');
    } else {
      throw new Error('Embeddings interface not available');
    }
    
    // Initialize session boundary manager if not already initialized
    if (sessionBoundaryManager && !sessionBoundaryManager.isInitialized) {
      try {
        logger.info('Initializing session boundary manager for token boundary awareness');
        await sessionBoundaryManager.initialize();
        logger.info('Session boundary manager initialized successfully');
        
        // Set up boundary check interval
        setInterval(checkBoundaryProximity, 60000); // Check every minute
        
        // Check for continuity token in options
        if (options.continuityToken) {
          logger.info('Continuity token detected, attempting to restore context');
          // Attempt to restore context from previous session
          await restoreContextAfterBoundaryCrossing();
        }
      } catch (boundaryError) {
        logger.warn(`Failed to initialize session boundary manager: ${boundaryError.message}`);
        // Continue anyway, with reduced boundary awareness capabilities
      }
    } else if (sessionBoundaryManager && sessionBoundaryManager.isInitialized) {
      logger.info('Session boundary manager already initialized');
      // Set up boundary check interval
      setInterval(checkBoundaryProximity, 60000); // Check every minute
      queryCache.clear();
      
      // Set up cache maintenance interval
      setInterval(() => {
        try {
          // Remove expired cache entries
          const now = Date.now();
          for (const [key, value] of queryCache.entries()) {
            if (now - value.timestamp > CONFIG.QUERY_CACHE_TTL) {
              queryCache.delete(key);
            }
          }
          
          // Limit cache size
          if (queryCache.size > CONFIG.QUERY_CACHE_SIZE) {
            const keys = Array.from(queryCache.keys());
            for (let i = 0; i < keys.length - CONFIG.QUERY_CACHE_SIZE; i++) {
              queryCache.delete(keys[i]);
            }
          }
        } catch (maintenanceError) {
          logger.warn(`Error in cache maintenance: ${maintenanceError.message}`);
        }
      }, 60000); // Clean up cache every minute
      
      logger.info('Cache initialized successfully');
    } else {
      logger.warn('Query cache not available or missing clear method');
    }
    
    // Verify embeddings are properly initialized
    if (!embeddingsInterface || (embeddingsInterface.isInitialized && !embeddingsInterface.isInitialized())) {
      const errorMsg = 'Embeddings interface not properly initialized';
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    
    // Make the embeddings interface available on the module exports
    module.exports.embeddingsInterface = embeddingsInterface;
    
    // Mark as initialized
    isInitialized = true;
    module.exports.isInitialized = true;
    
    // Emit initialization complete event
    const initEvent = {
      success: true,
      status: 'initialized',
      timestamp: Date.now(),
      embeddingsAvailable: true,
      boundaryAwarenessEnabled: boundaryAwarenessEnabled,
      embeddingsType: 'local-tfidf',
      embeddingDimensions: 1024 // Fixed dimension for our local implementation
    };
    
    // Emit both specific and standardized events
    eventBus.emit('semantic-context-manager:initialized', initEvent);
    eventBus.emit('component:initialized', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      status: 'success',
      details: initEvent
    });
    
    logger.info('Semantic context manager initialized successfully with local embeddings');
    return true;
  } catch (error) {
    const errorDetails = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code
    };
    logger.error('Failed to initialize semantic context manager', errorDetails);
    // Emit error event
    eventBus.emit('semantic-context-manager:initialization-failed', {
      error: errorDetails,
      timestamp: Date.now()
    });
    eventBus.emit('component:error', {
      component: COMPONENT_NAME,
      error: errorDetails,
      timestamp: Date.now(),
      details: errorDetails
    });
    return false;
  }
}
function analyzeQuery(query) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized');
      return {
        success: false,
        error: 'Semantic context manager not initialized',
        analysis: {
          type: 'unknown',
          isCodeQuery: false,
          isDocumentationQuery: false,
          isStructuralQuery: false,
          confidence: 0
        },
        metadata: {
          query,
          timestamp: Date.now(),
          status: 'error'
        }
      };
    }
    
    const lowerQuery = query.toLowerCase();
    
    // Check if query is code-specific
    const codeKeywords = [
      'function', 'class', 'method', 'variable', 'import', 'export',
      'parameter', 'return', 'code', 'implementation', 'syntax',
      'api', 'interface', 'module', 'component', 'algorithm'
    ];
    
    const isCodeQuery = codeKeywords.some(keyword => lowerQuery.includes(keyword)) ||
      /\bcode\b|\bfunction\b|\bclass\b|\bmethod\b|\bimplementation\b/.test(lowerQuery);
    
    // Check if query is explanatory
    const isExplanatoryQuery = lowerQuery.startsWith('how') || 
      lowerQuery.startsWith('explain') || 
      lowerQuery.startsWith('what is') ||
      lowerQuery.includes('describe') ||
      lowerQuery.includes('explain');
    
    // Check if query is about a specific file or path
    const isFileSpecificQuery = lowerQuery.includes('.js') || 
      lowerQuery.includes('.py') || 
      lowerQuery.includes('.md') ||
      lowerQuery.includes('file') ||
      lowerQuery.includes('directory') ||
      lowerQuery.includes('path');
    
    // Extract target file from query
    const targetFile = isFileSpecificQuery ? lowerQuery.split(' ').pop() : null;
    
    return {
      success: true,
      analysis: {
        type: isCodeQuery ? 'code' : isExplanatoryQuery ? 'explanatory' : 'unknown',
        isCodeQuery,
        isDocumentationQuery: isExplanatoryQuery,
        isStructuralQuery: isFileSpecificQuery,
        confidence: isCodeQuery || isExplanatoryQuery || isFileSpecificQuery ? 0.8 : 0.2
      },
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'success'
      }
    };
  } catch (error) {
    logger.error(`Error analyzing query: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Error analyzing query', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      analysis: {
        type: 'unknown',
        isCodeQuery: false,
        isDocumentationQuery: false,
        isStructuralQuery: false,
        confidence: 0
      },
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Search for context using semantic similarity
 */
// Import modularized embedding function
const { generateQueryEmbedding } = require('./semantic-context-manager/embeddings');

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Process a file using semantic chunking
 * @param {string} filePath - Path to the file
 * @returns {Promise<Object>} Standardized result with chunks and metadata
 */
async function processFileWithSemanticChunker(filePath) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          chunks: [],
          metadata: {
            filePath,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    logger.info(`Processing file with semantic chunker: ${filePath}`);
    
    // Process file with semantic chunker
    const chunks = await semanticChunker.processFile(filePath, {
      MAX_CHUNK_SIZE: CONFIG.MAX_CHUNK_SIZE,
      OVERLAP_SIZE: CONFIG.OVERLAP_SIZE
    });
    
    // Format chunks for embedding system
    const formattedChunks = semanticChunker.formatChunks(chunks);
    
    logger.info(`Created ${formattedChunks.length} semantic chunks for ${filePath}`);
    return {
      success: true,
      chunks: formattedChunks,
      metadata: {
        filePath,
        timestamp: Date.now(),
        count: formattedChunks.length
      }
    };
  } catch (error) {
    logger.error(`Error processing file with semantic chunker: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Error processing file with semantic chunker', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      chunks: [],
      metadata: {
        filePath,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Search for context based on semantic similarity
 * @param {string} query - Query text
 * @param {Object} options - Search options
 * @returns {Promise<Object>} Standardized result with context results and metadata
 */
async function searchContext(query, options = {}) {
  try {
    // Check initialization status
    if (!isInitialized) {
      logger.warn('Semantic context manager not initialized, initializing now...');
      const initSuccess = await initialize();
      if (!initSuccess) {
        return {
          success: false,
          error: 'Failed to initialize semantic context manager',
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    // Track metrics
    const startTime = Date.now();
    
    // Check for abort signal
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // Check if we need to reload embeddings and chunks
    if (embeddings.length === 0 || chunks.length === 0 || needsReload()) {
      logger.info('Loading embeddings and chunks');
      
      try {
        // Load embeddings using path utilities
        const embeddingsPath = pathUtils.normalize(CONFIG.embeddingsFile);
        if (!await pathUtils.exists(embeddingsPath)) {
          throw new Error(`Embeddings file not found: ${embeddingsPath}`);
        }
        
        // Read embeddings file
        const embeddingsData = await pathUtils.readFile(embeddingsPath);
        embeddings = embeddingsData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastEmbeddingsLoadTime = Date.now();
        
        // Load chunks using path utilities
        const chunksPath = pathUtils.normalize(CONFIG.chunksFile);
        if (!await pathUtils.exists(chunksPath)) {
          throw new Error(`Chunks file not found: ${chunksPath}`);
        }
        
        // Read chunks file
        const chunksData = await pathUtils.readFile(chunksPath);
        chunks = chunksData.split('\n')
          .filter(line => line.trim())
          .map(line => JSON.parse(line));
        
        lastChunksLoadTime = Date.now();
        
        // Build corpus stats
        if (CONFIG.ENABLE_CORPUS_STATS) {
          corpusStats = await buildCorpusStats();
        }
        
        // Emit data loaded event
        eventBus.emit('context:data:loaded', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          embeddingsCount: embeddings.length,
          chunksCount: chunks.length,
          loadTime: Date.now() - startTime
        });
        
        logger.info(`Loaded ${embeddings.length} embeddings and ${chunks.length} chunks in ${Date.now() - startTime}ms`);
      } catch (error) {
        logger.error(`Failed to load embeddings or chunks: ${error.message}`);
        
        // Emit error event
        eventBus.emit('context:data:error', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          error: error.message
        });
        
        return {
          success: false,
          error: error.message,
          results: [],
          metadata: {
            query,
            timestamp: Date.now(),
            status: 'error'
          }
        };
      }
    }
    
    // Set up options with standardized configuration access
    // Use a lower default similarity threshold to ensure more results
    const similarityThreshold = options.similarityThreshold || CONFIG.similarityThreshold || 0.15;
    const maxResults = options.maxResults || CONFIG.maxResults || 15; // Increase default max results
    const cacheKey = `${query}:${similarityThreshold}:${maxResults}`;
    
    // Check cache first
    if (queryCache.has(cacheKey)) {
      const cacheEntry = queryCache.get(cacheKey);
      const cacheAge = Date.now() - cacheEntry.timestamp;
      
      // Only use cache if it's not too old (using configured TTL)
      if (cacheAge < CONFIG.queryCacheTtl) {
        logger.debug('Using cached context', { query, cacheAge: `${Math.round(cacheAge/1000)}s` });
        
        // Emit cache hit event
        eventBus.emit('context:cache:hit', {
          component: COMPONENT_NAME,
          timestamp: Date.now(),
          query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
          cacheAge
        });
        
        return {
          success: true,
          results: cacheEntry.results,
          metadata: {
            query,
            timestamp: Date.now(),
            count: cacheEntry.results.length,
            options: {
              similarityThreshold,
              maxResults
            }
          }
        };
      }
    }
    
    // Analyze query to determine boosting strategy
    const analysis = analyzeQuery(query);
    logger.debug('Query analysis', { analysis });
    
    // Check if operation has been aborted
    if (options.signal && options.signal.aborted) {
      const abortError = new Error('Context search aborted');
      abortError.name = 'AbortError';
      throw abortError;
    }
    
    // MIGRATION: Use EmbeddingsService for embedding generation
    const queryEmbedding = await embeddingsService.generateQueryEmbedding(query); // MIGRATION: EmbeddingsService
    
    // Track similarity calculation time
    const similarityStartTime = Date.now();
    
    // Calculate similarity scores with standardized approach
    const results = embeddings.map((item, index) => {
      try {
        // Get corresponding chunk
        const chunk = chunks[index] || {};
        
        // MIGRATION: Use EmbeddingsService for cosine similarity
        let similarity = embeddingsService.cosineSimilarity(
          queryEmbedding,
          item.embedding || item.vector // Support both embedding and vector keys
        ); // MIGRATION: EmbeddingsService
        
        // Apply intelligent boosting based on query analysis
        let boostedSimilarity = similarity;
        const chunkType = inferChunkType(chunk);
        if (analysis.isCodeQuery && chunkType === 'code') {
          boostedSimilarity *= 1.3; // Boost code chunks for code queries
        } else if (analysis.isDocumentationQuery && chunkType === 'documentation') {
          boostedSimilarity *= 1.3; // Boost documentation for documentation queries
        } else if (analysis.isStructuralQuery && chunk.path && chunk.path.includes(analysis.targetFile)) {
          boostedSimilarity *= 1.5; // Boost chunks from the target file
        }
        
        // Emit similarity calculated event (for every 100th item to avoid event flood)
        if (index % 100 === 0) {
          eventBus.emit('context:similarity:calculated', {
            component: COMPONENT_NAME,
            timestamp: Date.now(),
            chunkType,
            similarity: Math.round(similarity * 100) / 100,
            boostedSimilarity: Math.round(boostedSimilarity * 100) / 100
          });
        }
        
        return {
          id: chunk.chunk_id || `chunk_${index}`,
          path: chunk.file || item.file,
          content: chunk.content || item.content,
          text: chunk.text || item.text, // Support both content and text properties
          similarity: boostedSimilarity,
          originalSimilarity: similarity,
          type: chunkType
        };
      } catch (error) {
        logger.error(`Error calculating similarity: ${error.message}`);
        return {
          id: `chunk_${index}`,
          path: item.file,
          content: item.content,
          text: item.text,
          similarity: 0,
          originalSimilarity: 0,
          type: inferChunkType(item)
        };
      }
    });
    
    // Sort by boosted similarity
    results.sort((a, b) => b.similarity - a.similarity);
    
    // Filter by similarity threshold
    const filteredResults = results.filter(item => item.similarity >= similarityThreshold);
    
    // Limit results
    const topResults = filteredResults.slice(0, maxResults);
    
    // Calculate similarity time
    const similarityTime = Date.now() - similarityStartTime;
    logger.debug(`Calculated similarity for ${embeddings.length} embeddings in ${similarityTime}ms`);
    
    // Add results to cache
    queryCache.set(cacheKey, {
      results: topResults,
      timestamp: Date.now()
    });
    
    // Emit cache miss event
    eventBus.emit('context:cache:miss', {
      component: COMPONENT_NAME,
      timestamp: Date.now(),
      query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
      resultCount: topResults.length,
      searchTime: Date.now() - startTime
    });
    
    return {
      success: true,
      results: topResults,
      metadata: {
        query,
        timestamp: Date.now(),
        count: topResults.length,
        searchTime: Date.now() - startTime,
        searchType: 'semantic',
        options: {
          similarityThreshold,
          maxResults
        }
      }
    };
  } catch (error) {
    logger.error(`Context search failed: ${error.message}`);
    
    // Emit error event for standardized error handling
    eventBus.emit('error', { 
      component: COMPONENT_NAME, 
      message: 'Context search failed', 
      error: error.message 
    });
    
    return {
      success: false,
      error: error.message,
      results: [],
      metadata: {
        query,
        timestamp: Date.now(),
        status: 'error'
      }
    };
  }
}


// MIGRATION: Use EmbeddingsService for query embedding generation
// MIGRATION: Legacy normalization and fallback logic removed. All normalization handled by EmbeddingsService.


/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Extract context from the current state
 * @param {Object} options - Extraction options
 * @returns {Promise<Object>} Standardized result with extracted context and metadata
 */
async function extractContext(options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Get current context
    const contextResult = await getCurrentContext(options);
    
    if (!contextResult.success) {
      logger.warn('Failed to extract context:', contextResult.error);
      return contextResult;
    }
    
    // Format the context for extraction
    const extractedContext = {
      content: contextResult.context,
      timestamp: Date.now(),
      metadata: {
        source: 'semantic-context-manager',
        boundary: await checkBoundaryProximity(),
        quality: await calculateContextQualityMetrics(contextResult.context, options)
      }
    };
    
    logger.info('Context extracted successfully');
    
    // Emit event
    eventBus.emit('context:extracted', {
      timestamp: Date.now(),
      size: JSON.stringify(extractedContext).length
    }, COMPONENT_NAME);
    
    return {
      success: true,
      context: extractedContext,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(extractedContext).length
      }
    };
  } catch (error) {
    logger.error(`Error extracting context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Store context for later retrieval
 * @param {Object} context - Context to store
 * @param {Object} options - Storage options
 * @returns {Promise<Object>} Standardized result with storage status and metadata
 */
async function storeContext(context, options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Validate context
    if (!context) {
      return {
        success: false,
        error: 'No context provided for storage',
        metadata: { timestamp: Date.now() }
      };
    }
    
    // Prepare context for storage
    const contextToStore = {
      content: context,
      timestamp: Date.now(),
      metadata: {
        source: 'semantic-context-manager',
        boundary: await checkBoundaryProximity(),
        options
      }
    };
    
    // Store context using context preservation system
    const storageResult = await storeContextForBoundaryCrossing(contextToStore);
    
    if (!storageResult) {
      logger.warn('Failed to store context');
      return {
        success: false,
        error: 'Failed to store context',
        metadata: { timestamp: Date.now() }
      };
    }
    
    logger.info('Context stored successfully');
    
    // Emit event
    eventBus.emit('context:stored', {
      timestamp: Date.now(),
      size: JSON.stringify(contextToStore).length
    }, COMPONENT_NAME);
    
    return {
      success: true,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(contextToStore).length
      }
    };
  } catch (error) {
    logger.error(`Error storing context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Extract context from current session
 * @param {Object} options - Options for context extraction
 * @returns {Promise<Object>} Extracted context with standardized result format
 */
async function extractContext(options = {}) {
  if (!initialized) {
    logger.warn(`${COMPONENT_NAME} not initialized, cannot extract context`);
    return { success: false, error: 'Not initialized' };
  }

  try {
    // Get current context
    const currentContext = await getCurrentContext(options);
    
    if (!currentContext.success) {
      return currentContext; // Forward the error
    }
    
    // Enhance context with metadata
    const enhancedContext = {
      ...currentContext.context,
      metadata: {
        extractionTime: Date.now(),
        source: 'semantic-context-manager',
        sessionId: sessionBoundaryManager ? sessionBoundaryManager.getCurrentSession().id : 'unknown',
        quality: getContextQualityMetrics()
      }
    };
    
    logger.info('Context extracted successfully');
    
    return {
      success: true,
      context: enhancedContext,
      timestamp: Date.now()
    };
  } catch (error) {
    logger.error(`Error extracting context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      timestamp: Date.now()
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Store context for future retrieval
 * @param {Object} context - Context to store
 * @param {Object} options - Options for context storage
 * @returns {Promise<Object>} Storage result
 */
async function storeContext(context, options = {}) {
  if (!initialized) {
    logger.warn(`${COMPONENT_NAME} not initialized, cannot store context`);
    return { success: false, error: 'Not initialized' };
  }
  
  if (!context) {
    logger.warn('No context provided for storage');
    return { success: false, error: 'No context provided' };
  }
  
  try {
    // Generate embedding for context if not already present
    if (!context.embedding) {
      // Convert context to string if it's an object
      const contextString = typeof context === 'object' ? JSON.stringify(context) : context;
      
      // Generate embedding
      if (localSemanticEmbeddings && typeof localSemanticEmbeddings.createEmbedding === 'function') {
        context.embedding = await localSemanticEmbeddings.createEmbedding(contextString);
      }
    }
    
    // Add metadata if not present
    if (!context.metadata) {
      context.metadata = {
        storageTime: Date.now(),
        source: 'semantic-context-manager',
        sessionId: sessionBoundaryManager ? sessionBoundaryManager.getCurrentSession().id : 'unknown'
      };
    }
    
    // Store in memory cache
    const cacheKey = `context-${Date.now()}`;
    contextCache.set(cacheKey, context);
    
    // Trim cache if it exceeds max size
    if (contextCache.size > config.maxCacheSize) {
      // Remove oldest entries
      const keysToDelete = Array.from(contextCache.keys())
        .sort((a, b) => {
          const timeA = parseInt(a.split('-')[1]);
          const timeB = parseInt(b.split('-')[1]);
          return timeA - timeB;
        })
        .slice(0, contextCache.size - config.maxCacheSize);
      
      keysToDelete.forEach(key => contextCache.delete(key));
    }
    
    logger.info('Context stored successfully');
    
    return {
      success: true,
      cacheKey,
      timestamp: Date.now()
    };
  } catch (error) {
    logger.error(`Error storing context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      timestamp: Date.now()
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Get current context with intelligent selection and prioritization
 * @param {Object} options - Options for context retrieval
 * @returns {Promise<Object>} Current context with standardized result format
 */
async function getCurrentContext(options = {}) {
  if (!isInitialized) {
    logger.warn(ERROR_MESSAGES.NOT_INITIALIZED);
    return { 
      success: false, 
      error: ERROR_MESSAGES.NOT_INITIALIZED,
      metadata: { timestamp: Date.now() }
    };
  }
  
  try {
    // Check boundary proximity for adaptive context selection
    const boundaryStatus = await checkBoundaryProximity();
    const isNearBoundary = boundaryStatus.status === 'warning' || boundaryStatus.status === 'critical';
    
    // Adjust options based on boundary proximity if adaptive selection is enabled
    const adaptiveOptions = { ...options };
    if (isNearBoundary && (options.adaptiveContextSelection !== false)) {
      adaptiveOptions.prioritizeRecentActivity = true;
      adaptiveOptions.maxContextSize = options.maxContextSize || Math.floor(CONFIG.maxResults * 0.7);
      logger.info('Adapting context selection due to boundary proximity');
    }
    
    // Perform semantic search to get relevant context
    const searchResult = await searchContext('', {
      maxResults: adaptiveOptions.maxContextSize || CONFIG.maxResults,
      includeMetadata: true
    });
    
    if (!searchResult.success) {
      logger.warn('Failed to retrieve context:', searchResult.error);
      return searchResult;
    }
    
    // Format and return the context
    const formattedContext = {
      items: searchResult.results,
      metadata: {
        timestamp: Date.now(),
        boundaryStatus: boundaryStatus.status,
        adaptiveSelection: isNearBoundary && (options.adaptiveContextSelection !== false)
      }
    };
    
    return {
      success: true,
      context: formattedContext,
      metadata: {
        timestamp: Date.now(),
        size: JSON.stringify(formattedContext).length
      }
    };
  } catch (error) {
    logger.error(`Error getting current context: ${error.message}`, error);
    return {
      success: false,
      error: error.message,
      metadata: { timestamp: Date.now() }
    };
  }
}

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * STANDARDIZED INTERFACE
 * 
 * This module exports a standardized interface for semantic context operations.
 * All components should use these functions to interact with the semantic context system.
 * 
 * This interface follows the standardized patterns defined in LEO_STANDARDIZATION.md
 */




// Calculate coverage (how much of the relevant context is included)
let coverageScore = 0;
let coverageWeights = {
  semanticMemory: 0.3,
  developmentHistory: 0.2,
  recentQueries: 0.15,
  activeEmbeddings: 0.25,
  activityFocus: 0.1
};

if (context.semanticMemory && context.semanticMemory.length > 0) {
  // Scale by both quantity and quality of memory items
  const qualityFactor = Math.min(1, context.semanticMemory.length / 10); // Scale up to 10 items
  const highPriorityRatio = context.semanticMemory.filter(item => 
    item.priority === 'critical' || item.priority === 'high'
  ).length / context.semanticMemory.length;
  
  coverageScore += coverageWeights.semanticMemory * qualityFactor * (0.5 + 0.5 * highPriorityRatio);
}

if (context.developmentHistory && context.developmentHistory.length > 0) {
  // Scale by recency and relevance of history items
  const recencyFactor = Math.min(1, context.developmentHistory.length / 5); // Scale up to 5 items
  coverageScore += coverageWeights.developmentHistory * recencyFactor;
}

if (context.recentQueries && context.recentQueries.length > 0) {
  coverageScore += coverageWeights.recentQueries * Math.min(1, context.recentQueries.length / 3);
}

if (context.activeEmbeddings && Object.keys(context.activeEmbeddings).length > 0) {
  coverageScore += coverageWeights.activeEmbeddings;
}
    

/**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * Get context quality metrics with enhanced boundary awareness
 * This function provides access to sophisticated context quality metrics
 * for token boundary awareness and context preservation
 * @param {Object} [options] - Options for metrics retrieval
 * @param {boolean} [options.includeTrends=true] - Whether to include trend analysis
 * @param {boolean} [options.includeUserFeedback=true] - Whether to include user feedback metrics
 * @param {boolean} [options.includePredictions=true] - Whether to include predictive metrics
 * @returns {Object} Comprehensive context quality metrics with boundary awareness
 */
      coherence: 0,
      completeness: 0,
      boundaryResilience: 0,
      userAlignmentScore: 0
    };
    
    // migrated to contextMetrics.js
    const { computeCoverageScore } = require('./semantic-context-manager/contextMetrics');
    metrics.coverage = computeCoverageScore(context);
    
    // Calculate relevance (how relevant the included context is to current activity)
    let relevanceScore = 0;
    let relevanceItemCount = 0;
    
    // Check semantic memory relevance with sophisticated scoring
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Weight items by priority
      const priorityWeights = {
        critical: 1.0,
        high: 0.8,
        medium: 0.5,
        low: 0.2
      };
      
      const memoryRelevance = context.semanticMemory.reduce((sum, item) => {
        const priorityWeight = priorityWeights[item.priority] || 0.5;
        return sum + (item.relevanceScore || 0.5) * priorityWeight;
      }, 0) / context.semanticMemory.length;
      
      relevanceScore += memoryRelevance;
      relevanceItemCount++;
    }
    
    // Check development history relevance
    if (context.developmentHistory && context.developmentHistory.length > 0) {
      // Calculate relevance based on recency and activity focus
      const historyRelevance = 0.7; // Simplified for now, could be more sophisticated
      relevanceScore += historyRelevance;
      relevanceItemCount++;
    }
    
    // Factor in activity focus if available
    if (context.activityFocus) {
      const activityRelevance = 0.9; // High relevance for current activity focus
      relevanceScore += activityRelevance;
      relevanceItemCount++;
    }
    
    metrics.relevance = relevanceItemCount > 0 ? relevanceScore / relevanceItemCount : 0;
    
    // Calculate recency (how recent the context elements are)
    let recencyScore = 0;
    const now = Date.now();
    
    if (context.semanticMemory && context.semanticMemory.length > 0) {
      // Calculate average age of memory items in hours
      const avgAgeHours = context.semanticMemory.reduce((sum, item) => {
        const timestamp = item.timestamp || now;
        const ageHours = (now - timestamp) / (1000 * 60 * 60);
        return sum + ageHours;
      }, 0) / context.semanticMemory.length;
      
      // Convert to recency score (newer = higher score)
      // Assume 24 hours is the threshold for "recent"
      recencyScore = Math.max(0, 1 - (avgAgeHours / 24));
    }
    
    metrics.recency = recencyScore;
    
    // migrated to contextMetrics.js
    const { computeDiversityScore } = require('./semantic-context-manager/contextMetrics');
    metrics.diversity = computeDiversityScore(context);
    
    // Calculate coherence (how well the context elements fit together)
    let coherenceScore = 0;
    
    if (context.semanticMemory && context.semanticMemory.length > 2) {
      // Simplified coherence calculation - could be more sophisticated
      // Higher relevance scores generally indicate better coherence
      coherenceScore = metrics.relevance * 0.8;
    }
    
    metrics.coherence = coherenceScore;
    
    // Calculate completeness (how complete the context is for the current task)
    metrics.completeness = (metrics.coverage + metrics.relevance) / 2;
    
    // Calculate boundary resilience (how well the context will survive a token boundary)
    if (includeBoundaryProximity) {
      // Higher quality contexts are more resilient to boundary crossings
      metrics.boundaryResilience = (
        metrics.relevance * 0.4 +
        metrics.coherence * 0.3 +
        metrics.completeness * 0.3
      );
    } else {
      metrics.boundaryResilience = 0.5; // Default value when not considering boundaries
    }
    
    // User alignment score - how well the context aligns with user feedback
    // This would ideally use actual user feedback data
  
  /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
   * Get context quality metrics with enhanced boundary awareness
   * This function provides access to sophisticated context quality metrics
   * for token boundary awareness and context preservation
   * @param {Object} [options] - Options for metrics retrieval
   * @param {boolean} [options.includeTrends=true] - Whether to include trend analysis
   * @param {boolean} [options.includeUserFeedback=true] - Whether to include user feedback metrics
   * @param {boolean} [options.includePredictions=true] - Whether to include predictive metrics
   * @returns {Object} Comprehensive context quality metrics with boundary awareness
   */
const getContextQualityMetrics = (options = {}) => {
    const {
      includeTrends = true,
      includeUserFeedback = true,
      includePredictions = true
    } = options;
    
    // Get base metrics from last calculation or defaults
    const baseMetrics = this.lastContextQualityMetrics || {
      overallQuality: 0.5, // Default to medium quality
      coverage: 0.5,
      relevance: 0.5,
      recency: 0.5,
      diversity: 0.5,
      coherence: 0.5,
      completeness: 0.5,
      boundaryResilience: 0.5,
      userAlignmentScore: 0.5
    };
    
    // Start with base metrics
    const metrics = { ...baseMetrics };
    
    // Add timestamp for tracking
    metrics.timestamp = Date.now();
    
    // Add trend analysis if requested and history available
    if (includeTrends && this.contextQualityHistory && this.contextQualityHistory.length > 0) {
      // Calculate trends based on historical data
      const historyWindow = this.contextQualityHistory.slice(-5); // Last 5 measurements
      
      // Calculate simple trend direction and magnitude
      const oldestQuality = historyWindow[0].overallQuality;
      const newestQuality = historyWindow[historyWindow.length - 1].overallQuality;
      const qualityDelta = newestQuality - oldestQuality;
      
      metrics.trends = {
        direction: qualityDelta > 0.05 ? 'improving' : (qualityDelta < -0.05 ? 'declining' : 'stable'),
        magnitude: Math.abs(qualityDelta),
        historyAvailable: true,
        dataPoints: historyWindow.length
      };
    } else {
      metrics.trends = {
        direction: 'stable',
        magnitude: 0,
        historyAvailable: false
      };
    }
    
    // Add user feedback metrics if available
    if (includeUserFeedback) {
      metrics.userFeedback = {
        // This would ideally come from actual user feedback data
        alignmentScore: 0.85,
        satisfactionScore: 0.7,
        explicitFeedbackAvailable: false,
        implicitFeedbackAvailable: true
      };
    }
    
    // Add predictive metrics if requested
    if (includePredictions) {
      // Calculate boundary crossing predictions
      // Use the getBoundaryStatus function directly
      const boundaryStatus = getBoundaryStatus();
      
      metrics.predictions = {
        nextBoundaryQuality: metrics.boundaryResilience * metrics.overallQuality,
        confidenceScore: 0.8,
        preservationLikelihood: metrics.boundaryResilience,
        boundaryProximity: boundaryStatus.percentage || 0
      };
    }
    
    return metrics;
}
  
  /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
   * Store context for boundary crossing
   * @param {Object} context - Context to store
   * @returns {Promise<boolean>} Success status
   * @private
   */
  const storeContextForBoundaryCrossing = async function(context) {
    try {
      // Get storage path
      const storagePath = path.join(CONFIG.CONTEXT_STORAGE_PATH, 'boundary-crossings');
      
      // Ensure directory exists
      await fsPromises.mkdir(storagePath, { recursive: true });
      
      // Generate filename with timestamp and session ID
      const sessionId = context.sessionId || 'unknown-session';
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `context-${sessionId}-${timestamp}.json`;
      
      // Write context to file
      await fsPromises.writeFile(
        path.join(storagePath, filename),
        JSON.stringify(context, null, 2),
        'utf8'
      );
      
      // Store reference to latest context file
      contextPreservationState.latestContextFile = filename;
      
      return true;
    } catch (error) {
      logger.error(`Error storing context for boundary crossing: ${error.message}`);
      throw error;
    }
  };

    
async function restoreContextAfterBoundaryCrossing(savedContext = null) {
  try {
    // Update restoration state
    const restorationStartTime = Date.now();
    
    // Emit event to notify of restoration start
    eventBus.emit('semantic-context-manager:restoration-start', {
      timestamp: restorationStartTime
    });
    
    // Get latest context file
    const storagePath = path.join(CONFIG.CONTEXT_STORAGE_PATH, 'boundary-crossings');
    let contextFile;
    
    if (contextPreservationState.latestContextFile) {
      // Use the known latest context file if available
      contextFile = contextPreservationState.latestContextFile;
    } else {
      // Find the latest context file
      const files = await fsPromises.readdir(storagePath);
      const contextFiles = files.filter(file => file.startsWith('context-') && file.endsWith('.json'));
      
      if (contextFiles.length === 0) {
        contextFile = null;
      } else {
        contextFile = contextFiles[0];
      }
    }
    
    if (contextFile) {
      // Read and parse context file
      const contextData = JSON.parse(
        await fsPromises.readFile(path.join(storagePath, contextFile), 'utf8')
      );
      
      // Restore context
      if (contextData.semanticContext) {
        // Restore semantic context
        await restoreSemanticContext(contextData.semanticContext);
      }
      
      // Update restoration state
      const restorationEndTime = Date.now();
      
      // Emit event to notify of successful restoration
      eventBus.emit('semantic-context-manager:restoration-success', {
        timestamp: restorationEndTime,
        duration: restorationEndTime - restorationStartTime,
        contextFile
      });
      
      logger.info(`Context successfully restored after boundary crossing in ${restorationEndTime - restorationStartTime}ms`);
      
      return {
        success: true,
        timestamp: restorationEndTime,
        duration: restorationEndTime - restorationStartTime,
        contextFile
      };
    } 
    } catch (error) {
      // Emit event to notify of failed restoration
      eventBus.emit('semantic-context-manager:restoration-failure', {
        timestamp: Date.now(),
        error: error.message
      });
      
      logger.error(`Error restoring context after boundary crossing: ${error.message}`);
      
      return {
        success: false,
        error: error.message,
        timestamp: Date.now()
      };
    }
  }
  
  /**
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
 * LEGACY MIGRATION PROXY: semantic-context-manager.js
 * 
 * All logic has been migrated to modular files in ./semantic-context-manager/
 * This file is kept ONLY to support legacy imports during the migration window.
 * 
 * TODO: Remove this file after all consumers are migrated.
 */

module.exports = require('./semantic-context-manager/index.js');
*
   * Restore semantic context from saved context
   * @param {Object} semanticContext - Semantic context to restore
   * @returns {Promise<boolean>} Success status
   */
const restoreSemanticContext = async function(semanticContext) {
  try {
    // Restore recent queries if available
    if (semanticContext.recentQueries && Array.isArray(semanticContext.recentQueries)) {
      const recentQueries = [...semanticContext.recentQueries];
      // Store the queries in the appropriate service
    }
    // Restore active embeddings if available
    if (semanticContext.activeEmbeddings) {
      // Implementation depends on embeddings module structure
      // This is a placeholder for actual implementation
      logger.info('Restored active embeddings from preserved context');
    }
    return true;
  } catch (error) {
    logger.error(`Error restoring semantic context: ${error.message}`);
    throw error;
  }
};

// Import modularized boundary functions
// MIGRATION: Use modular BoundaryService via DI
const { createBoundaryService } = require('./semantic-context-manager/boundary');

const boundaryService = createBoundaryService({
  logger,
  eventBus,
  state: {
    boundaryAwarenessEnabled,
    contextPreservationState,
    sessionBoundaryManager,
    lastBoundaryStatus
  },
  preserveContextForBoundaryCrossing,
  restoreContextAfterBoundaryCrossing
});

const getStatus = function() {
  return {
    isInitialized: getIsInitialized(),
    cacheStats: getCacheStats(),
    boundaryAwareness: {
      enabled: boundaryService.state.boundaryAwarenessEnabled,
      status: boundaryService.state.lastBoundaryStatus,
      contextPreservation: boundaryService.state.contextPreservationState?.isPreserving
    }
  };
};

const semanticContextManager = {
  // Core functions
  initialize,
  isInitialized,
  getStatus,

  // Context operations
  searchContext,
  getCurrentContext,
  injectContext,
  generateEnhancedPrompt,
  extractContext,
  storeContext,

  // Embeddings interface
  async getEmbeddingsInterface() {
    throw new Error('EmbeddingsService must be injected and used for all embedding operations. Legacy fallback logic is removed.');
  },

  // File processing
  processFileWithSemanticChunker,
  processFilesWithSemanticChunker,

  // Cache management
  invalidateCache,

  // Token boundary awareness
  getBoundaryStatus() {
    if (!isInitialized || !boundaryAwarenessEnabled) {
      return { status: 'unknown', percentage: 0, enabled: false };
    }
    try {
      if (sessionBoundaryManager && sessionBoundaryManager.isInitialized) {
        const boundaryStatus = sessionBoundaryManager.getBoundaryProximity();
        return {
          ...boundaryStatus,
          isPreservingContext: contextPreservationState.isPreserving,
          enabled: true
        };
      }
      return {
        status: lastBoundaryStatus || 'unknown',
        percentage: 0,
        isPreservingContext: contextPreservationState.isPreserving,
        enabled: boundaryAwarenessEnabled
      };
    } catch (error) {
      logger.error(`Error getting boundary status: ${error.message}`);
      return { status: 'error', percentage: 0, enabled: false, error: error.message };
    }
  },
